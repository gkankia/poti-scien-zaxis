<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Urbanyx - áƒ¤áƒáƒ—áƒ˜</title>
    <!-- Open Graph (Facebook, LinkedIn) -->
    <meta property="og:title" content="urban analytics with local knowledge">
    <meta property="og:description" content="urban analytics with local knowledge">
    <meta property="og:image" content="https://static.wixstatic.com/media/9c6bfd_7ed45f6184af45c29d0e05571bbec790~mv2.png">
    <meta property="og:url" content="https://poti.zaxis.ge?lat=...&lng=...&z=...&bearing=...&pitch=..." />    
    <meta property="og:type" content="website">

    <link href="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>    
    <script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
 
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">        
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Georgian:wght@100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">

</head>
<body>
    <div id="modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2 style="text-align: center; margin-bottom: 15px;">áƒ™áƒ˜áƒ—áƒ®áƒ•áƒáƒ áƒ˜</h2>
            <div id="cellInfo" class="info-box"></div>
            
            <form id="surveyForm">
                <div class="question">
                    <label>1. áƒ áƒ áƒáƒ¡áƒáƒ™áƒ˜áƒ¡ áƒ®áƒáƒ áƒ—?</label>
                    <div class="radio-group" required>
                        <label><input type="radio" name="age" value="17" required>&lt;17</label>
                        <label><input type="radio" name="age" value="18-25">18-25</label>
                        <label><input type="radio" name="age" value="26-35">26-35</label>
                        <label><input type="radio" name="age" value="36-45">36-45</label>
                        <label><input type="radio" name="age" value="45-55">45-55</label>
                        <label><input type="radio" name="age" value="56+">56+</label>
                    </div>
                </div>
                <div class="question">
                    <label>2. áƒ¡áƒ¥áƒ”áƒ¡áƒ˜:</label>
                    <div class="radio-group" required>
                        <label><input type="radio" name="gender" value="male" required> áƒ›áƒáƒ›áƒ áƒáƒ‘áƒ˜áƒ—áƒ˜</label>
                        <label><input type="radio" name="gender" value="female"> áƒ›áƒ“áƒ”áƒ“áƒ áƒáƒ‘áƒ˜áƒ—áƒ˜</label>
                        <!--<label><input type="radio" name="gender" value="other"> áƒ¡áƒ®áƒ•áƒ</label>-->
                    </div>
                </div>
                <div class="question">
                    <label>3. áƒ áƒáƒ›áƒ“áƒ”áƒœáƒáƒ“ áƒ£áƒ¡áƒáƒ¤áƒ áƒ—áƒ®áƒáƒ áƒ‘áƒáƒ¦áƒ—áƒáƒœ/áƒ¡áƒ™áƒáƒšáƒáƒ¡áƒ—áƒáƒœ áƒ¤áƒ”áƒ®áƒ˜áƒ— áƒ¡áƒ˜áƒáƒ áƒ£áƒšáƒ˜, áƒ›áƒáƒ— áƒ¨áƒáƒ áƒ˜áƒ¡ áƒ’áƒ–áƒ˜áƒ¡ áƒ’áƒáƒ“áƒáƒ™áƒ•áƒ”áƒ—áƒ?</label>
                    <div class="radio-group" required>
                        <label><input type="radio" name="safety" value="very_unsafe" required> áƒ«áƒáƒšáƒ˜áƒáƒœ áƒ¡áƒáƒ®áƒ˜áƒ¤áƒáƒ—áƒáƒ</label>
                        <label><input type="radio" name="safety" value="somewhat_unsafe"> áƒ›áƒ”áƒ¢áƒ¬áƒ˜áƒšáƒáƒ“ áƒ¡áƒáƒ®áƒ˜áƒ¤áƒáƒ—áƒáƒ</label>
                        <label><input type="radio" name="safety" value="neutral"> áƒ¡áƒáƒ¨áƒ£áƒáƒšáƒ</label>
                        <label><input type="radio" name="safety" value="somewhat_safe"> áƒ›áƒ”áƒ¢áƒ¬áƒ˜áƒšáƒáƒ“ áƒ£áƒ¡áƒáƒ¤áƒ áƒ—áƒ®áƒáƒ</label>
                        <label><input type="radio" name="safety" value="very_safe"> áƒ«áƒáƒšáƒ˜áƒáƒœ áƒ£áƒ¡áƒáƒ¤áƒ áƒ—áƒ®áƒ</label>
                    </div>
                </div>
                <div class="question">
                    <label>4. áƒ›áƒáƒœáƒ˜áƒ¨áƒœáƒ” <u>áƒ¡áƒáƒ›áƒ˜ áƒ›áƒ—áƒáƒ•áƒáƒ áƒ˜ áƒ›áƒ˜áƒ–áƒ”áƒ–áƒ˜,</u> áƒ áƒ˜áƒ¡ áƒ’áƒáƒ›áƒáƒª, áƒáƒ› áƒáƒ áƒ”áƒáƒšáƒ¨áƒ˜, áƒ‘áƒáƒ•áƒ¨áƒ•áƒ˜áƒ¡áƒ—áƒ•áƒ˜áƒ¡ áƒ’áƒáƒ“áƒáƒáƒ“áƒ’áƒ˜áƒšáƒ”áƒ‘áƒ áƒ¡áƒáƒ®áƒ˜áƒ¤áƒáƒ—áƒ áƒ¨áƒ”áƒ˜áƒ«áƒšáƒ”áƒ‘áƒ áƒ˜áƒ§áƒáƒ¡</label>
                    <div class="checkbox-group">
                      <label><input type="checkbox" name="reason" value="sidewalk" > áƒ•áƒ˜áƒ¬áƒ áƒ áƒ¢áƒ áƒáƒ¢áƒ£áƒáƒ áƒ˜</label>
                      <label><input type="checkbox" name="reason" value="speed"> áƒ¡áƒáƒáƒ•áƒ¢áƒáƒ›áƒáƒ‘áƒ˜áƒšáƒ áƒ›áƒáƒ«áƒ áƒáƒáƒ‘áƒ˜áƒ¡ áƒ›áƒáƒ¦áƒáƒšáƒ˜ áƒ¡áƒ˜áƒ©áƒ¥áƒáƒ áƒ”</label>
                      <label><input type="checkbox" name="reason" value="crossing"> áƒ£áƒ¨áƒ£áƒ¥áƒœáƒ˜áƒ¨áƒœáƒ/áƒ›áƒáƒ£áƒœáƒ˜áƒ¨áƒœáƒáƒ•áƒ˜ áƒ’áƒáƒ“áƒáƒ¡áƒáƒ¡áƒ•áƒšáƒ”áƒšáƒ˜</label>
                      <label><input type="checkbox" name="reason" value="road"> áƒ’áƒáƒœáƒ˜áƒ”áƒ áƒ˜ áƒ¡áƒáƒáƒ•áƒ¢áƒáƒ›áƒáƒ‘áƒ˜áƒšáƒ áƒ–áƒáƒšáƒ”áƒ‘áƒ˜</label>
                      <label><input type="checkbox" name="reason" value="drivers"> áƒ›áƒ«áƒ¦áƒáƒšáƒ”áƒ‘áƒ˜áƒ¡ áƒ¡áƒáƒ®áƒ˜áƒ¤áƒáƒ—áƒ áƒ›áƒáƒœáƒ”áƒ•áƒ áƒ˜</label>
                      <label><input type="checkbox" name="reason" value="streetlighting"> áƒªáƒ£áƒ“áƒ˜ áƒ’áƒáƒ áƒ”áƒ’áƒáƒœáƒáƒ—áƒ”áƒ‘áƒ</label>
                      <!-- Other option -->
                      <label><input type="checkbox" name="reason" value="other_reason" id="reasonOtherCheckbox"> áƒ¡áƒ®áƒ•áƒ:
                        <input type="text" id="reasonOtherText" placeholder="áƒ¨áƒ”áƒœáƒ˜ áƒáƒ–áƒ áƒ˜" style="margin-left:5px; display:none;">
                      </label>
                    </div>
                </div>
                <div class="question">
                    <label>5. áƒ›áƒáƒœáƒ˜áƒ¨áƒœáƒ” <u>áƒ¡áƒáƒ›áƒ˜ áƒáƒ áƒ˜áƒáƒ áƒ˜áƒ¢áƒ”áƒ¢áƒ˜,</u> áƒ áƒáƒ›áƒ”áƒšáƒ˜áƒª áƒ›áƒœáƒ˜áƒ¨áƒ•áƒœáƒ”áƒšáƒáƒ•áƒáƒœáƒáƒ“ áƒ›áƒ˜áƒ’áƒáƒ©áƒœáƒ˜áƒáƒ— áƒ¥áƒ£áƒ©áƒáƒ¨áƒ˜ áƒ‘áƒáƒ•áƒ¨áƒ•áƒ”áƒ‘áƒ˜áƒ¡ áƒ£áƒ¡áƒáƒ¤áƒ áƒ—áƒ®áƒ áƒ’áƒáƒ“áƒáƒáƒ“áƒ’áƒ˜áƒšáƒ”áƒ‘áƒ˜áƒ¡ áƒ£áƒ–áƒ áƒ£áƒœáƒ•áƒ”áƒšáƒ¡áƒáƒ§áƒáƒ¤áƒáƒ“</label>
                    <div class="checkbox-group">
                      <label><input type="checkbox" name="priority" value="better_sidewalk"> áƒ™áƒ”áƒ—áƒ˜áƒšáƒ›áƒáƒ¬áƒ§áƒáƒ‘áƒ˜áƒšáƒ˜ áƒ¢áƒ áƒáƒ¢áƒ£áƒáƒ áƒ”áƒ‘áƒ˜ áƒ“áƒ áƒ›áƒ˜áƒ›áƒ–áƒ˜áƒ“áƒ•áƒ”áƒšáƒ˜ áƒ¡áƒáƒ¯áƒáƒ áƒ áƒ¡áƒ˜áƒ•áƒ áƒªáƒ”</label>
                      <label><input type="checkbox" name="priority" value="safe_crossing"> áƒ£áƒ¡áƒáƒ¤áƒ áƒ—áƒ®áƒ áƒ¡áƒáƒ¤áƒ”áƒ®áƒ›áƒáƒ•áƒšáƒ áƒ’áƒáƒ“áƒáƒ¡áƒáƒ¡áƒ•áƒšáƒ”áƒšáƒ”áƒ‘áƒ˜</label>
                      <label><input type="checkbox" name="priority" value="enforcement"> áƒ›áƒ™áƒáƒªáƒ áƒ˜ áƒ™áƒáƒœáƒ¢áƒ áƒáƒšáƒ˜ áƒ¡áƒáƒ’áƒ–áƒáƒ áƒ›áƒáƒ«áƒ áƒáƒáƒ‘áƒ˜áƒ¡ áƒ¬áƒ”áƒ¡áƒ”áƒ‘áƒ˜áƒ¡ áƒ“áƒáƒ áƒ¦áƒ•áƒ”áƒ•áƒáƒ–áƒ”</label>
                      <label><input type="checkbox" name="priority" value="limit_speed"> áƒ›áƒáƒ¥áƒ¡. áƒ“áƒáƒ¡áƒáƒ¨áƒ•áƒ”áƒ‘áƒ˜ áƒ¡áƒ˜áƒ©áƒ¥áƒáƒ áƒ˜áƒ¡ áƒ¨áƒ”áƒ–áƒ¦áƒ£áƒ“áƒ•áƒ 30 áƒ™áƒ›/áƒ¡áƒ—-áƒ›áƒ“áƒ”</label>
                      <label><input type="checkbox" name="priority" value="infrastructure">áƒ˜áƒœáƒ áƒáƒ¡áƒ¢áƒ áƒ£áƒ¥áƒ¢áƒ£áƒ áƒ£áƒšáƒ˜ áƒ’áƒáƒ£áƒ›áƒ¯áƒáƒ‘áƒ”áƒ¡áƒ”áƒ‘áƒ (áƒ¨áƒ£áƒ¥áƒœáƒ˜áƒ¨áƒáƒœáƒ˜, áƒ’áƒ–áƒ˜áƒ¡ áƒ˜áƒœáƒ™áƒšáƒ£áƒ–áƒ˜áƒ£áƒ áƒ˜ áƒ“áƒ˜áƒ–áƒáƒ˜áƒœáƒ˜, áƒ“áƒ áƒ.áƒ¨.)</label>
                      <!-- Other option -->
                      <label><input type="checkbox" name="priority" value="other_priority" id="priorityOtherCheckbox"> áƒ¡áƒ®áƒ•áƒ:
                        <input type="text" id="priorityOtherText" placeholder="áƒ¨áƒ”áƒœáƒ˜ áƒáƒ–áƒ áƒ˜" style="margin-left:5px; display:none;">
                      </label>
                    </div>
                </div>
                <button class="send" type="submit">áƒ’áƒáƒ’áƒ–áƒáƒ•áƒœáƒ</button>
            </form>
        </div>
    </div>

    <div class="map-container">
        <div id="map">
            <div class="search-container">
                <input type="text" id="kindergartenSearch" placeholder="áƒ›áƒáƒ«áƒ”áƒ‘áƒœáƒ”: áƒ‘áƒáƒ¦áƒ˜, áƒ¡áƒ™áƒáƒšáƒ áƒáƒœ áƒ›áƒ˜áƒ¡áƒáƒ›áƒáƒ áƒ—áƒ˜..." />
                <div class="search-results" id="searchResults"></div>
            </div>

            <!-- Action Buttons on Map -->
            <div class="map-action-buttons" style="position: absolute; top: 50%; right: 10px; z-index: 1000; display: flex; flex-direction: column; gap: 10px;">
                <button class="map-action-btn" onclick="openDataSourcePopup()" style="width: 29px; height: 29px; color: white; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s;" title="áƒ›áƒáƒœáƒáƒªáƒ”áƒ›áƒ—áƒ áƒ¬áƒ§áƒáƒ áƒáƒ”áƒ‘áƒ˜">
                    <span class="material-symbols-outlined" style="font-size: 18px; color: #333333;">database</span>
                </button>
                <button class="map-action-btn" onclick="openFeedbackPopup()" style="width: 29px; height: 29px; color: white; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s;" title="áƒ£áƒ™áƒ£áƒ™áƒáƒ•áƒ¨áƒ˜áƒ áƒ˜">
                    <span class="material-symbols-outlined" style="font-size: 18px; color: #333333;">feedback</span>
                </button>
            </div>

            <div id="sharePanel" class="icon-panel">
                <button id="fbShareBtn" class="share-btn" title="Share on Facebook">
                    <img src="https://raw.githubusercontent.com/gkankia/kindergarten-tbilisi/refs/heads/main/assets/icons/facebook.png" alt="Facebook" />
                </button>
                <button id="liShareBtn" class="share-btn" title="Share on LinkedIn">
                    <img src="https://raw.githubusercontent.com/gkankia/kindergarten-tbilisi/refs/heads/main/assets/icons/linkedin.png" alt="LinkedIn" />
                </button>
                <button id="copyLinkBtn" class="share-btn" title="Copy link">
                    <img src="https://raw.githubusercontent.com/gkankia/kindergarten-tbilisi/refs/heads/main/assets/icons/link.png" alt="Copy Link">
                </button>
                <span id="copyMessage">áƒ™áƒáƒáƒ˜áƒ áƒ”áƒ‘áƒ£áƒšáƒ˜áƒ!</span>
            </div>
            
            <footer>
                <div class="zaxis">
                    <p>built with &#129360; by</p>
                    <a href="https://zaxis.ge"><img src="https://raw.githubusercontent.com/axis-Z/urbanyxv1/refs/heads/main/img/white-transparent-background.png" alt="" width="75"></a>
                </div>
            </footer>
        </div>
        
        <div class="sidebar">
            <div class="title"><h1>URBANYX</h1></div>
            <div class="subtitle"><h3>áƒáƒœáƒáƒšáƒ˜áƒ¢áƒ˜áƒ™áƒ áƒ£áƒ¡áƒáƒ¤áƒ áƒ—áƒ®áƒ áƒ¥áƒáƒšáƒáƒ¥áƒ˜áƒ¡áƒ—áƒ•áƒ˜áƒ¡</h3></div>

            <div class="tab-buttons">
                <button class="tab-btn active" onclick="switchTab('survey')">áƒ™áƒ˜áƒ—áƒ®áƒ•áƒáƒ áƒ˜</button>
                <button class="tab-btn disabled" id="resultsTabBtn" onclick="switchTab('results')" data-tooltip="áƒ’áƒ—áƒ®áƒáƒ•áƒ—, áƒ¨áƒ”áƒáƒ•áƒ¡áƒ”áƒ— áƒ™áƒ˜áƒ—áƒ®áƒ•áƒáƒ áƒ˜">áƒ¨áƒ”áƒ“áƒ”áƒ’áƒ”áƒ‘áƒ˜</button>
            </div>
            
            <div id="surveyTab" class="tab-content active">
                <div class="section">
                    <p style="font-size: 14px; padding: 10px 0 0 0; text-align: left;">
                        áƒ’áƒáƒ”áƒªáƒáƒœáƒ˜ áƒ˜áƒœáƒ¡áƒ¢áƒ áƒ£áƒ¥áƒªáƒ˜áƒáƒ¡
                    </p>
                    <div class="dropdown-item" style="display: block;">
                        <ol class="instruction-list">
                            <li>áƒáƒ˜áƒ áƒ•áƒ”áƒš áƒ áƒ˜áƒ’áƒ¨áƒ˜, áƒ’áƒ—áƒ®áƒáƒ•áƒ— áƒ¨áƒ”áƒáƒ•áƒ¡áƒ áƒ™áƒ˜áƒ—áƒ®áƒ•áƒáƒ áƒ˜!</li>
                            <li>áƒáƒ›áƒ˜áƒ¡áƒ—áƒ•áƒ˜áƒ¡, áƒ“áƒáƒ–áƒ£áƒ›áƒ” áƒ¡áƒáƒ¡áƒ£áƒ áƒ•áƒ”áƒš áƒšáƒáƒ™áƒáƒªáƒ˜áƒáƒ–áƒ”</li>
                            <li>áƒ¨áƒ”áƒ’áƒ˜áƒ«áƒšáƒ˜áƒ áƒ’áƒáƒ›áƒáƒ˜áƒ§áƒ”áƒœáƒ áƒáƒ•áƒ¢áƒáƒ›áƒáƒ¢áƒ£áƒ áƒ˜ áƒœáƒáƒ•áƒ˜áƒ’áƒáƒªáƒ˜áƒ˜áƒ¡ áƒ¦áƒ˜áƒšáƒáƒ™áƒ˜áƒª</li>
                            <li>áƒ“áƒáƒáƒ™áƒšáƒ˜áƒ™áƒ” áƒ¨áƒ”áƒ¡áƒáƒ‘áƒáƒ›áƒ˜áƒ¡ áƒ™áƒ•áƒáƒ“áƒ áƒáƒ¢áƒ–áƒ”</li>
                            <li>áƒ¨áƒ”áƒáƒ•áƒ¡áƒ” áƒ™áƒ˜áƒ—áƒ®áƒ•áƒáƒ áƒ˜ áƒ“áƒ áƒ¨áƒ”áƒ’áƒ•áƒáƒ¢áƒ§áƒáƒ‘áƒ˜áƒœáƒ”, áƒ áƒáƒ›áƒ“áƒ”áƒœáƒáƒ“ áƒ£áƒ¡áƒáƒ¤áƒ áƒ—áƒ®áƒáƒ áƒ”áƒ¡ áƒ’áƒáƒ áƒ”áƒ›áƒ, áƒ’áƒáƒœáƒ¡áƒáƒ™áƒ£áƒ—áƒ áƒ”áƒ‘áƒ˜áƒ— áƒ‘áƒáƒ•áƒ¨áƒ•áƒ”áƒ‘áƒ˜áƒ¡áƒ—áƒ•áƒ˜áƒ¡</li>
                            <li>áƒ’áƒáƒ“áƒáƒ áƒ—áƒ” áƒ¨áƒ”áƒ“áƒ”áƒ’áƒ”áƒ‘áƒ˜áƒ¡ áƒáƒáƒœáƒ”áƒšáƒ–áƒ” áƒ“áƒ áƒ’áƒáƒ”áƒªáƒáƒœáƒ˜ áƒ¨áƒ”áƒ¯áƒáƒ›áƒ”áƒ‘áƒ£áƒš áƒáƒœáƒáƒšáƒ˜áƒ–áƒ¡</li>
                        </ol>
                    </div>
                </div>
            </div>
            
            <div id="resultsTab" class="tab-content">
                <div class="section">
                    <button class="dropdown-toggle">áƒáƒœáƒáƒšáƒ˜áƒ–áƒ˜áƒ¡ áƒáƒáƒœáƒ”áƒšáƒ˜ â–¼</button>
                    <div class="dropdown-item">
                        <p style="font-size: 12px; line-height: 1.8;">
                            â€¢ áƒ¨áƒ”áƒ’áƒ˜áƒ«áƒšáƒ˜áƒ áƒ¨áƒ”áƒªáƒ•áƒáƒšáƒ áƒ’áƒáƒ“áƒáƒáƒ“áƒ’áƒ˜áƒšáƒ”áƒ‘áƒ˜áƒ¡ áƒ“áƒ áƒ áƒ“áƒ áƒ¤áƒáƒ áƒ›áƒ<br>
                            â€¢ áƒ—áƒ”áƒ›áƒáƒ¢áƒ£áƒ áƒáƒ“ áƒáƒ’áƒ áƒ”áƒ’áƒ˜áƒ áƒ”áƒ‘áƒ£áƒšáƒ˜ áƒ˜áƒœáƒ¤áƒáƒ áƒ›áƒáƒªáƒ˜áƒ<br>
                            â€¢ áƒ’áƒ”áƒáƒ’áƒ áƒáƒ¤áƒ˜áƒ£áƒšáƒ˜ áƒ¡áƒ˜áƒáƒ®áƒšáƒáƒ•áƒ˜áƒ— áƒ’áƒáƒ¤áƒ˜áƒšáƒ¢áƒ áƒ£áƒšáƒ˜ áƒ›áƒáƒœáƒáƒªáƒ”áƒ›áƒ”áƒ‘áƒ˜<br>
                            â€¢ áƒ›áƒáƒ áƒ¨áƒ áƒ£áƒ¢áƒ”áƒ‘áƒ˜áƒ¡ áƒ¨áƒ”áƒ¤áƒáƒ¡áƒ”áƒ‘áƒ áƒ£áƒ¡áƒáƒ¤áƒ áƒ—áƒ®áƒáƒ”áƒ‘áƒ˜áƒ¡ áƒ›áƒ˜áƒ®áƒ”áƒ“áƒ•áƒ˜áƒ—<br>
                            â€¢ áƒ¡áƒ™áƒáƒšáƒ˜áƒ¡ áƒ˜áƒœáƒ¤áƒ áƒáƒ¡áƒ¢áƒ áƒ£áƒ¥áƒ¢áƒ£áƒ áƒ˜áƒ¡ áƒ¨áƒ”áƒ¤áƒáƒ¡áƒ”áƒ‘áƒ<br>
                            â€¢ áƒ›áƒ˜áƒ›áƒ“áƒ”áƒ‘áƒáƒ áƒ” áƒ£áƒ áƒ‘áƒáƒœáƒ£áƒšáƒ˜ áƒ’áƒáƒ áƒ”áƒ›áƒáƒ¡ áƒ•áƒ˜áƒ–áƒ£áƒáƒšáƒ£áƒ áƒ˜ áƒ›áƒáƒ¡áƒáƒšáƒ<br>
                            â€¢ áƒ¡áƒáƒ’áƒ–áƒáƒ áƒ£áƒ¡áƒáƒ¤áƒ áƒ—áƒ®áƒáƒ”áƒ‘áƒ˜áƒ¡ áƒáƒœáƒáƒšáƒ˜áƒ–áƒ˜
                        </p>
                    </div>
                </div>
                    
                <div class="section">
                    <label class="time-interval">áƒ’áƒáƒ“áƒáƒáƒ“áƒ’áƒ˜áƒšáƒ”áƒ‘áƒ˜áƒ¡ áƒ“áƒ áƒ (áƒ¬áƒ£áƒ—áƒ˜)</label>
                    <select id="timeResults">
                        <option value="10">10</option>
                        <option value="15" selected>15</option>
                        <option value="20">20</option>
                        <option value="25">25</option>
                        <!--<option value="30">30</option>-->
                    </select>
                    <br>
                    <label class="travel-mode" style="margin-top: 12px;">áƒ’áƒáƒ“áƒáƒáƒ“áƒ’áƒ˜áƒšáƒ”áƒ‘áƒ˜áƒ¡ áƒ¤áƒáƒ áƒ›áƒ</label>
                    <div class="toggle-group">
                        <div class="toggle active" data-mode="walking" onclick="setResultsMode('walking')">áƒ¤áƒ”áƒ®áƒ˜áƒ—<br><span class="material-symbols-outlined">footprint</span></div>
                        <div class="toggle" data-mode="cycling" onclick="setResultsMode('cycling')">áƒ•áƒ”áƒšáƒ<br><span class="material-symbols-outlined">directions_bike</span></div>
                    </div>
                </div>
                
                <div id="aggregateResults" class="results" style="display: none;">
                    <div class="dropdown-header" onclick="toggleDropdown('resultsDropdown')">
                        <span>áƒ™áƒ˜áƒ—áƒ®áƒ•áƒáƒ áƒ˜áƒ¡ áƒ¨áƒ”áƒ“áƒ”áƒ’áƒ”áƒ‘áƒ˜</span>
                        <span class="dropdown-arrow" id="resultsDropdownArrow">â–¼</span>
                    </div>
                    <div class="dropdown-content" id="resultsDropdown">
                        <div id="aggregateContent"></div>
                    </div>
                </div>

                 <!-- Urban Environment Section 
                 <div id="urbanEnvironmentResults" class="results streetview-section">
                    <div class="dropdown-header" onclick="toggleDropdown('urbanEnvironmentDropdown')">
                        <span>áƒ£áƒ áƒ‘áƒáƒœáƒ£áƒšáƒ˜ áƒ’áƒáƒ áƒ”áƒ›áƒ</span>
                        <span class="dropdown-arrow" id="urbanEnvironmentDropdownArrow">â–¼</span>
                    </div>
                    <div class="dropdown-content" id="urbanEnvironmentDropdown">
                        <div id="urbanEnvironmentContainer"></div>
                    </div>
                </div>-->
                
                <div id="kindergartenResults" class="results" style="display: none;">
                    <div class="dropdown-header" onclick="toggleDropdown('kindergartenDropdown')">
                        <span>áƒ‘áƒáƒ’áƒ-áƒ‘áƒáƒ¦áƒ”áƒ‘áƒ˜ áƒáƒ áƒ”áƒáƒšáƒ¨áƒ˜ (<span id="kindergartenCount">0</span>)</span>
                        <span class="dropdown-arrow" id="kindergartenDropdownArrow">â–¼</span>
                    </div>
                    <div class="dropdown-content" id="kindergartenDropdown">
                        <div class="kindergarten-list" id="kindergartenList"></div>
                    </div>
                </div>

                <div id="schoolSummaryResults" class="results" style="display: none;">
                    <div class="dropdown-header" onclick="toggleDropdown('schoolSummaryDropdown')">
                        <span>áƒ¡áƒ™áƒáƒšáƒ˜áƒ¡ áƒ˜áƒœáƒ¤áƒ áƒáƒ¡áƒ¢áƒ áƒ£áƒ¥áƒ¢áƒ£áƒ áƒ˜áƒ¡ áƒ¨áƒ”áƒ¤áƒáƒ¡áƒ”áƒ‘áƒ</span>
                        <span class="dropdown-arrow" id="schoolSummaryDropdownArrow">â–¼</span>
                    </div>
                    <div class="dropdown-content" id="schoolSummaryDropdown">
                        <div id="schoolSummaryContent"></div>
                    </div>
                </div>

                <!-- Add this after the kindergartenResults div -->
                <div id="streetViewResults" class="results streetview-section">
                    <div class="dropdown-header" onclick="toggleDropdown('streetViewDropdown')">
                        <span>áƒ áƒáƒ’áƒáƒ  áƒ’áƒáƒ›áƒáƒ˜áƒ§áƒ£áƒ áƒ”áƒ‘áƒ áƒ›áƒ˜áƒ›áƒ“áƒ”áƒ‘áƒáƒ áƒ” áƒ’áƒáƒ áƒ”áƒ›áƒ</span>
                        <span class="dropdown-arrow" id="streetViewDropdownArrow">â–¼</span>
                    </div>
                    <div class="dropdown-content" id="streetViewDropdown">
                        <div id="streetViewContainer"></div>
                    </div>
                </div>

                <div id="accidentResults" class="results" style="display: none;">
                    <div class="dropdown-header" onclick="toggleDropdown('accidentDropdown')">
                        <span>áƒ¡áƒáƒ’áƒ–áƒáƒ áƒ£áƒ¡áƒáƒ¤áƒ áƒ—áƒ®áƒáƒ”áƒ‘áƒ</span>
                        <span class="dropdown-arrow" id="accidentDropdownArrow">â–¼</span>
                    </div>
                    <div class="dropdown-content" id="accidentDropdown">
                        <!--<div class="chart-container">
                            <h4>áƒáƒ•áƒáƒ áƒ˜áƒ”áƒ‘áƒ˜áƒ¡ áƒ™áƒáƒ¢áƒ”áƒ’áƒáƒ áƒ˜áƒ”áƒ‘áƒ˜</h4>
                            <div class="chart-wrapper tiny">
                                <canvas id="accidentCategoryChart"></canvas>
                            </div>
                        </div>-->
                        <div class="accident-list" id="accidentList"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="share.js"></script>
    <script src="questionnaires.js"></script>
    <script src="data-feedback.js"></script>
    <script src="load-accidents.js"></script>
    <script src="route-generation-analysis.js"></script>
    <script src="streetview.js"></script>
    <!--<script src="kidfriendliness.js"></script>-->
    <script src="draggable-divider.js"></script>
    <script src="schoolsummary.js"></script>

    <script>

        // Initialize survey submission tracking
        let userHasSubmittedSurvey = true;

        // Function to enable results tab
        function enableResultsTab() {
            const resultsTabBtn = document.getElementById('resultsTabBtn');
            if (resultsTabBtn) {
                resultsTabBtn.classList.remove('disabled');
                resultsTabBtn.removeAttribute('data-tooltip');
                console.log('Results tab enabled');
            }
        }

        // Also update the tab button initialization-results tab active on page load
        window.addEventListener('DOMContentLoaded', () => {
            const resultsTabBtn = document.getElementById('resultsTabBtn');
            if (resultsTabBtn) {
                resultsTabBtn.classList.remove('disabled');
                resultsTabBtn.removeAttribute('data-tooltip');
            }
        });

        const APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbxw-gD_HSr3ZxM3u6gZg8W5BqmDLHacCttQ7MCSq8S8vYvk2-Wv5Kr1AZiMqylwbWOK/exec';
        
        const GEORGIAN_WORDS = ['áƒ›áƒ–áƒ”', 'áƒ›áƒ—áƒ', 'áƒ¬áƒ§áƒáƒšáƒ˜', 'áƒ®áƒ”', 'áƒ§áƒ•áƒáƒ•áƒ˜áƒšáƒ˜', 'áƒ¥áƒáƒ áƒ˜', 'áƒ¦áƒ áƒ£áƒ‘áƒ”áƒšáƒ˜', 'áƒ›áƒ“áƒ˜áƒœáƒáƒ áƒ”', 'áƒ¢áƒ‘áƒ', 'áƒ•áƒ”áƒšáƒ˜', 'áƒ¢áƒ§áƒ”', 'áƒ¥áƒ•áƒ', 'áƒªáƒ', 'áƒ›áƒ˜áƒ¬áƒ', 
                                'áƒ•áƒáƒ áƒ¡áƒ™áƒ•áƒšáƒáƒ•áƒ˜', 'áƒ›áƒ—áƒ•áƒáƒ áƒ”', 'áƒœáƒ˜áƒ¡áƒšáƒ˜', 'áƒ—áƒáƒ•áƒšáƒ˜', 'áƒ¬áƒ•áƒ˜áƒ›áƒ', 'áƒ áƒáƒ“áƒ˜áƒ', 'áƒ¬áƒ˜áƒ’áƒœáƒ˜', 'áƒ¡áƒáƒ®áƒšáƒ˜', 'áƒ’áƒ–áƒ', 'áƒ®áƒ˜áƒ“áƒ˜', 'áƒ™áƒáƒ áƒ˜', 'áƒ¤áƒáƒœáƒ¯áƒáƒ áƒ', 
                                'áƒ‘áƒáƒ¦áƒ˜', 'áƒ”áƒ–áƒ', 'áƒ¥áƒ£áƒ©áƒ', 'áƒ›áƒáƒ”áƒ“áƒáƒœáƒ˜', 'áƒªáƒ˜áƒ®áƒ”', 'áƒ”áƒ™áƒšáƒ”áƒ¡áƒ˜áƒ', 'áƒ›áƒ£áƒ–áƒ”áƒ£áƒ›áƒ˜', 'áƒáƒáƒ áƒ™áƒ˜', 'áƒ‘áƒ£áƒšáƒ•áƒáƒ áƒ˜', 'áƒ¡áƒ™áƒ•áƒ”áƒ áƒ˜', 'áƒ¨áƒáƒ“áƒ áƒ”áƒ•áƒáƒœáƒ˜', 'áƒ«áƒ”áƒ’áƒšáƒ˜', 
                                'áƒ—áƒ”áƒáƒ¢áƒ áƒ˜', 'áƒ™áƒ˜áƒœáƒ', 'áƒ§áƒ£áƒ áƒ«áƒ”áƒœáƒ˜', 'áƒ•áƒáƒ¨áƒšáƒ˜', 'áƒ›áƒ¡áƒ®áƒáƒšáƒ˜', 'áƒáƒ¢áƒáƒ›áƒ˜', 'áƒ¤áƒáƒ áƒ—áƒáƒ®áƒáƒšáƒ˜', 'áƒšáƒ˜áƒ›áƒáƒœáƒ˜', 'áƒŸáƒáƒšáƒ', 'áƒ™áƒ˜áƒ•áƒ˜', 'áƒ‘áƒáƒœáƒáƒœáƒ˜', 'áƒ¡áƒáƒ–áƒáƒ›áƒ—áƒ áƒ', 
                                'áƒáƒšáƒ˜áƒ’áƒáƒ áƒ¥áƒ˜áƒ', 'áƒ™áƒáƒ áƒ£áƒ¤áƒªáƒ˜áƒ', 'áƒ¡áƒáƒáƒáƒ¢áƒ áƒ˜áƒáƒ áƒ¥áƒ', 'áƒ§áƒáƒ©áƒáƒ¦áƒ”áƒ‘áƒ˜', 'áƒáƒ•áƒ¢áƒáƒ‘áƒ£áƒ¡áƒ˜', 'áƒ¢áƒ áƒáƒ¢áƒ£áƒáƒ áƒ˜', 'áƒ‘áƒ¢áƒœáƒ‘áƒ«áƒœ'];
        
        function toggleDropdown(id) {
            const content = document.getElementById(id);
            const arrow = document.getElementById(id + 'Arrow');
            content.classList.toggle('open');
            arrow.classList.toggle('open');
        }

        let carAccidentData = null;
        let currentSelectedKindergarten = null;
        let currentSelectedKindergartenName = null;
        let currentIsochronePolygon = null;
        let allKindergartenFeatures = [];

        mapboxgl.accessToken = "pk.eyJ1Ijoiam9yam9uZTkwIiwiYSI6ImNrZ3R6M2FvdTBwbmwycXBibGRqM2w2enYifQ.BxjvFSGqefuC9yFCrXC-nQ";
        
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/jorjone90/cmd1cg82i000101s61qwaca16',
            center: [41.6736517072779, 42.14632838970241],
            zoom: 14,
            attributionControl: true,
            preserveDrawingBuffer: true
        });

        map.addControl(new mapboxgl.NavigationControl());

        let userLocation = null;

        const geolocate = new mapboxgl.GeolocateControl({
            positionOptions: { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 },
            trackUserLocation: true,
            showUserHeading: true,
            fitBoundsOptions: { maxZoom: 15 }
        });

        map.addControl(geolocate);

        geolocate.on('geolocate', (e) => {
            userLocation = [e.coords.longitude, e.coords.latitude];
            console.log('User location updated:', userLocation);
        });
        
        let kindergartenData = null;
        let marker = null;
        let surveyDataGeoJSON = { type: 'FeatureCollection', features: [] };
        let currentFeature = null;
        let currentTab = 'survey';
        let resultsMode = 'walking';
        let chartInstances = {};
        
        const ORIGIN_LNG = 41.0, ORIGIN_LAT = 41.0, GRID_EXTENT_LNG = 47.0, GRID_EXTENT_LAT = 44.0;
        const GRID_SIZE_METERS = 100;
        const MAP_CENTER = [41.6735867098894, 42.142609674570565]; // Poti center
        const MAX_GRID_RADIUS_KM = 20; // 20km radius limit

        // FIXED REFERENCE LATITUDE - use map center latitude for all calculations
        const REFERENCE_LAT = 42.142609674570565;

        function metersToDegrees(lat, meters) {
            return {
                latDeg: meters / 111320,
                lonDeg: meters / (111320 * Math.cos(lat * Math.PI / 180))
            };
        }

        // Calculate FIXED grid size once using reference latitude
        const { latDeg: GRID_SIZE_LAT, lonDeg: GRID_SIZE_LNG } = metersToDegrees(REFERENCE_LAT, GRID_SIZE_METERS);

        function generateThreeWordName(cellId) {
            const [x, y] = cellId.split(',').map(Number);
            const hash = Math.abs((x * 73856093) ^ (y * 19349663));
            return `${GEORGIAN_WORDS[hash % GEORGIAN_WORDS.length]}.${GEORGIAN_WORDS[Math.floor(hash / GEORGIAN_WORDS.length) % GEORGIAN_WORDS.length]}.${GEORGIAN_WORDS[Math.floor(hash / (GEORGIAN_WORDS.length * GEORGIAN_WORDS.length)) % GEORGIAN_WORDS.length]}`;
        }

        function getCellId(lng, lat) {
            // Use FIXED grid sizes calculated at initialization
            return `${Math.floor((lng - ORIGIN_LNG) / GRID_SIZE_LNG)},${Math.floor((lat - ORIGIN_LAT) / GRID_SIZE_LAT)}`;
        }

        function getCellBounds(cellId) {
            const [x, y] = cellId.split(',').map(Number);
            // Use FIXED grid sizes calculated at initialization
            const minLng = ORIGIN_LNG + x * GRID_SIZE_LNG;
            const minLat = ORIGIN_LAT + y * GRID_SIZE_LAT;
            return [
                [minLng, minLat],
                [minLng + GRID_SIZE_LNG, minLat],
                [minLng + GRID_SIZE_LNG, minLat + GRID_SIZE_LAT],
                [minLng, minLat + GRID_SIZE_LAT],
                [minLng, minLat]
            ];
        }

        function getCellCenter(cellId) {
            const bounds = getCellBounds(cellId);
            return [(bounds[0][0] + bounds[2][0]) / 2, (bounds[0][1] + bounds[2][1]) / 2];
        }

        // BUILD FIXED GRID

        let fixedGrid = { type: 'FeatureCollection', features: [] };
        
        // LOAD DATA FROM SHEETS

        async function loadDataFromSheets() {
            try {
                const response = await fetch(APPS_SCRIPT_URL);
                const data = await response.json();
                
                console.log('Raw data from sheets:', data); // DEBUG
                
                if (data.status === 'success' && data.rows) {
                    const gridMap = {};
                    
                    data.rows.forEach(row => {
                        const gridName = row[1];
                        const cellId = row[2];
                        const lat = parseFloat(row[3]);
                        const lng = parseFloat(row[4]);
                        
                        console.log('Processing row - reason:', row[8], 'priority:', row[9]); // DEBUG
                        
                        if (!gridMap[gridName]) {
                            gridMap[gridName] = {
                                type: 'Feature',
                                geometry: { type: 'Point', coordinates: [lng, lat] },
                                properties: { gridName, cellId, responses: [] }
                            };
                        }
                        
                        gridMap[gridName].properties.responses.push({
                            timestamp: row[0],
                            age: row[5],
                            gender: row[6],
                            safety: row[7],
                            reason: row[8] || '',
                            priority: row[9] || ''
                        });
                    });
                    
                    surveyDataGeoJSON.features = Object.values(gridMap);
                    
                    console.log('Loaded features:', surveyDataGeoJSON.features); // DEBUG
                    console.log('Total responses loaded:', surveyDataGeoJSON.features.reduce((sum, f) => sum + f.properties.responses.length, 0)); // DEBUG
                    
                    if (map.isStyleLoaded() && map.getSource('survey-data')) {
                        map.getSource('survey-data').setData(surveyDataGeoJSON);
                    }
                }
            } catch (err) {
                console.error('Failed to load data:', err);
            }
        }

        // LOAD AND FILTER CAR ACCIDENTS DATA WITHIN ISOCHRONE


        /**
         * Show route between two points
         * @param {Array} from - [lng, lat]
         * @param {Array} to - [lng, lat]
         * @param {string} mode - 'walking' or 'cycling'
         * @param {boolean} permanent - true = click route, false = hover route
         */

        // ROUTE GENERATION AND SPATIAL ANALYSIS
        // FUNCTION TO ANALYZE ACCIDENT DENSITY ALONG ROUTE SEGMENTS

        // Update the search input event listeners
// ============================================================
// INTEGRATED SEARCH AND FACILITY MANAGEMENT
// Supports both Kindergartens and Schools
// ============================================================

// Track current facility type
let currentFacilityType = null; // 'kindergarten' or 'school'

// Load public school data
let publicSchoolData = null;

async function loadPublicSchoolData() {
    try {
        const response = await fetch('https://raw.githubusercontent.com/axis-Z/urbanyxv1/main/data/public_schools.geojson');
        if (!response.ok) throw new Error('Network response was not ok');
        publicSchoolData = await response.json();
        console.log('Public school data loaded:', publicSchoolData.features.length, 'schools');
    } catch (err) {
        console.error('Failed to load public school data:', err);
    }
}

// Call this on page load
loadPublicSchoolData();

// Search functionality with expand/collapse
const searchInput = document.getElementById('kindergartenSearch');
const searchContainer = document.querySelector('.search-container');
const searchResults = document.getElementById('searchResults');

// Set initial placeholder to search icon
searchInput.placeholder = 'search';

// Add expand/collapse functionality
searchInput.addEventListener('focus', () => {
    searchContainer.classList.add('expanded');
    searchInput.classList.add('expanded');
    searchInput.placeholder = 'áƒ›áƒáƒ«áƒ”áƒ‘áƒœáƒ”: áƒ‘áƒáƒ¦áƒ˜, áƒ¡áƒ™áƒáƒšáƒ áƒáƒœ áƒ›áƒ˜áƒ¡áƒáƒ›áƒáƒ áƒ—áƒ˜...';
});

searchInput.addEventListener('blur', () => {
    if (searchInput.value === '') {
        searchContainer.classList.remove('expanded');
        searchInput.classList.remove('expanded');
        searchInput.placeholder = 'search';
    }
});

// Search input handler - searches both kindergartens and schools
searchInput.addEventListener('input', (e) => {
    const query = e.target.value.trim().toLowerCase();
    
    if (query.length > 0) {
        searchContainer.classList.add('expanded');
        searchInput.classList.add('expanded');
    }
    
    if (query.length < 1) {
        searchResults.style.display = 'none';
        return;
    }

    const bounds = map.getBounds();
    const minLng = bounds.getWest();
    const maxLng = bounds.getEast();
    const minLat = bounds.getSouth();
    const maxLat = bounds.getNorth();

    let allMatches = [];

    // Search kindergartens
    if (kindergartenData && kindergartenData.features) {
        const kindergartenMatches = kindergartenData.features.filter(f => {
            const [lng, lat] = f.geometry.coordinates;
            const inBounds = lng >= minLng && lng <= maxLng && lat >= minLat && lat <= maxLat;
            const name = (f.properties.name || '').toLowerCase();
            const location = (f.properties.name_location || '').toLowerCase();
            const matchesQuery = name.includes(query) || location.includes(query);
            return inBounds && matchesQuery;
        }).map(f => ({
            type: 'kindergarten',
            name: f.properties.name,
            address: f.properties.name_location,
            phone: f.properties.phone || '',
            lng: f.geometry.coordinates[0],
            lat: f.geometry.coordinates[1]
        }));
        allMatches.push(...kindergartenMatches);
    }

    // Search schools
    if (publicSchoolData && publicSchoolData.features) {
        const schoolMatches = publicSchoolData.features.filter(f => {
            const [lng, lat] = f.geometry.coordinates;
            const inBounds = lng >= minLng && lng <= maxLng && lat >= minLat && lat <= maxLat;
            const name = (f.properties.áƒ¡áƒ™áƒáƒšáƒ || '').toLowerCase();
            const matchesQuery = name.includes(query);
            return inBounds && matchesQuery;
        }).map(f => ({
            type: 'school',
            name: f.properties.áƒ¡áƒ™áƒáƒšáƒ,
            students: f.properties.students || 0,
            occupancy: f.properties.occupancy || 0,
            condition: f.properties["áƒ¨áƒ”áƒœáƒáƒ‘áƒ˜áƒ¡ áƒ›áƒ“áƒ’áƒáƒ›áƒáƒ áƒ”áƒáƒ‘áƒ"] || 0,
            lng: f.geometry.coordinates[0],
            lat: f.geometry.coordinates[1]
        }));
        allMatches.push(...schoolMatches);
    }

    allMatches = allMatches.slice(0, 10);

    if (allMatches.length === 0) {
        searchResults.style.display = 'none';
        return;
    }

    searchResults.innerHTML = allMatches.map(item => {
        if (item.type === 'kindergarten') {
            return `
                <div class="search-result-item" data-type="kindergarten" data-lng="${item.lng}" data-lat="${item.lat}">
                    <div class="result-name">${item.name}</div>
                    <div class="result-address">${item.address}</div>
                    ${item.phone ? `<div class="result-phone">${item.phone}</div>` : ''}
                </div>
            `;
        } else {
            return `
                <div class="search-result-item" data-type="school" data-lng="${item.lng}" data-lat="${item.lat}">
                    <div class="result-name">${item.name}</div>
                    <div class="result-address" style="font-size: 11px;">áƒ›áƒáƒ¡áƒ¬áƒáƒ•áƒšáƒ”áƒ”áƒ‘áƒ˜: <b>${item.students}</b></div>
                </div>
            `;
        }
    }).join('');

    searchResults.style.display = 'block';

    searchResults.querySelectorAll('.search-result-item').forEach(item => {
        item.addEventListener('click', () => {
            const lng = parseFloat(item.dataset.lng);
            const lat = parseFloat(item.dataset.lat);
            const type = item.dataset.type;
            
            searchInput.value = item.querySelector('.result-name').textContent.replace('ğŸ’ ', '').replace('ğŸ« ', '');
            searchResults.style.display = 'none';
            searchInput.blur();
            
            currentFacilityType = type;
            
            if (type === 'kindergarten') {
                zoomToKindergarten({ lng, lat });
            } else if (type === 'school') {
                zoomToSchool({ lng, lat });
            }
        });
    });
});

// Close search results when clicking outside
document.addEventListener('click', (e) => {
    if (!searchContainer.contains(e.target) && !searchResults.contains(e.target)) {
        searchResults.style.display = 'none';
        if (searchInput.value === '') {
            searchContainer.classList.remove('expanded');
            searchInput.classList.remove('expanded');
            searchInput.placeholder = 'search';
        }
    }
});

function displayKindergartenList(pointsInIsochrone) {
    const list = document.getElementById('kindergartenList');
    const count = document.getElementById('kindergartenCount');
    const header = document.querySelector('#kindergartenResults .dropdown-header span:first-child');
    
    count.textContent = pointsInIsochrone.length;
    
    // Update header text for kindergartens
    if (header) {
        header.innerHTML = `áƒ‘áƒáƒ’áƒ-áƒ‘áƒáƒ¦áƒ”áƒ‘áƒ˜ (<span id="kindergartenCount">${pointsInIsochrone.length}</span>)`;
    }

    if (pointsInIsochrone.length === 0) {
        list.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">áƒ‘áƒáƒ’áƒ-áƒ‘áƒáƒ¦áƒ”áƒ‘áƒ˜ áƒáƒ  áƒ›áƒáƒ˜áƒ«áƒ”áƒ‘áƒœáƒ</p>';
        return;
    }

    // Sort selected kindergarten first, rest by distance
    if (currentSelectedKindergarten && currentSelectedKindergartenName) {
        const [selLng, selLat] = [currentSelectedKindergarten.lng, currentSelectedKindergarten.lat];
        pointsInIsochrone.sort((a, b) => {
            if (a.properties.name === currentSelectedKindergartenName) return -1;
            if (b.properties.name === currentSelectedKindergartenName) return 1;
            const distA = turf.distance(turf.point([selLng, selLat]), turf.point(a.geometry.coordinates));
            const distB = turf.distance(turf.point([selLng, selLat]), turf.point(b.geometry.coordinates));
            return distA - distB;
        });
    }

    // Render list
    list.innerHTML = pointsInIsochrone.map(feature => {
        const props = feature.properties;
        const isSelected = props.name === currentSelectedKindergartenName;
        let html = `<div class="kindergarten-item${isSelected ? ' selected' : ''}" 
                    data-lng="${feature.geometry.coordinates[0]}" 
                    data-lat="${feature.geometry.coordinates[1]}" 
                    data-name="${props.name || ''}">`;

        if (props.image && props.image !== 'null' && props.image !== '') {
            html += `<img src="${props.image}" style="width:100%; height:150px; object-fit:cover; border-radius:5px; margin-bottom:10px;" onerror="this.style.display='none'">`;
        }

        html += `<h4>${props.name || 'áƒ£áƒ¡áƒáƒ®áƒ”áƒšáƒ'}</h4>`;
        if (props.location) html += `<p>ğŸ“ ${props.location}</p>`;
        if (props.phone && props.phone !== 'null' && props.phone !== '') html += `<p>ğŸ“ ${props.phone}</p>`;
        if (props.email && props.email !== 'null' && props.email !== '') html += `<p>âœ‰ï¸ ${props.email}</p>`;
        if (props.facebook && props.facebook !== 'null' && props.facebook !== '') {
            html += `<p>ğŸ‘¥ <a href="${props.facebook}" target="_blank" style="color:#6c86cf; text-decoration:none;">Facebook</a></p>`;
        }

        html += '</div>';
        return html;
    }).join('');

    let currentHoveredFeatureName = null;

    // Add hover & click behavior
    pointsInIsochrone.forEach((feature, index) => {
        const item = list.children[index];
        if (!item) return;

        const featureLngLat = feature.geometry.coordinates;
        const isSelected = feature.properties.name === currentSelectedKindergartenName;

        item.addEventListener('mouseenter', () => {
            if (isSelected) return;
            if (!map.getLayer('isochrone-points-layer')) return;

            if (currentHoveredFeatureName && currentHoveredFeatureName !== feature.properties.name) {
                if (map.getLayer('temp-route-line-colored')) map.removeLayer('temp-route-line-colored');
                if (map.getLayer('temp-route-line-colored-outline-glow-outer')) map.removeLayer('temp-route-line-colored-outline-glow-outer');
                if (map.getLayer('temp-route-line-colored-outline-glow-middle')) map.removeLayer('temp-route-line-colored-outline-glow-middle');
                if (map.getSource('temp-route-line-segments')) map.removeSource('temp-route-line-segments');
                const existingPopup = document.getElementById('routePopup');
                if (existingPopup) existingPopup.remove();
            }

            currentHoveredFeatureName = feature.properties.name;

            map.setPaintProperty('isochrone-points-layer', 'circle-radius', [
                'case', ['==', ['get', 'name'], feature.properties.name], 8, 4
            ]);
            map.setPaintProperty('isochrone-points-layer', 'circle-color', [
                'case', ['==', ['get', 'name'], feature.properties.name], '#f768a1', '#ae017e'
            ]);

            let from;
            if (userLocation) {
                from = userLocation;
            } else if (currentSelectedKindergarten) {
                from = [currentSelectedKindergarten.lng, currentSelectedKindergarten.lat];
            } else {
                return;
            }

            showRoute(from, featureLngLat, resultsMode, false);
        });

        item.addEventListener('click', () => {
            const lng = parseFloat(item.dataset.lng);
            const lat = parseFloat(item.dataset.lat);
            const name = item.dataset.name;

            currentHoveredFeatureName = null;
            currentSelectedKindergarten = { lng, lat };
            currentSelectedKindergartenName = name;

            displayKindergartenList(pointsInIsochrone);
            zoomToKindergarten({ lng, lat });

            if (userLocation) {
                showRoute(userLocation, [lng, lat], resultsMode, true);
            } else {
                showRouteToSelected([lng, lat], resultsMode, true);
            }

            if (typeof loadStreetViewForKindergarten === 'function') {
                loadStreetViewForKindergarten({ lng, lat });
            }
        });
    });
}

function displaySchoolList(schoolsInIsochrone) {
    const list = document.getElementById('kindergartenList');
    const count = document.getElementById('kindergartenCount');
    const header = document.querySelector('#kindergartenResults .dropdown-header span:first-child');
    
    count.textContent = schoolsInIsochrone.length;
    
    // Update header text for schools
    if (header) {
        header.innerHTML = `áƒ¡áƒ™áƒáƒšáƒ”áƒ‘áƒ˜ (<span id="kindergartenCount">${schoolsInIsochrone.length}</span>)`;
    }

    if (schoolsInIsochrone.length === 0) {
        list.innerHTML = '<p style="text-align: center; font-size: 12px; color: #999; padding: 20px;">áƒ¡áƒ™áƒáƒšáƒ”áƒ‘áƒ˜ áƒáƒ  áƒ›áƒáƒ˜áƒ«áƒ”áƒ‘áƒœáƒ</p>';
        return;
    }

    // Sort selected school first, rest by distance
    if (currentSelectedKindergarten && currentSelectedKindergartenName) {
        const [selLng, selLat] = [currentSelectedKindergarten.lng, currentSelectedKindergarten.lat];
        schoolsInIsochrone.sort((a, b) => {
            if (a.properties.name === currentSelectedKindergartenName) return -1;
            if (b.properties.name === currentSelectedKindergartenName) return 1;
            const distA = turf.distance(turf.point([selLng, selLat]), turf.point(a.geometry.coordinates));
            const distB = turf.distance(turf.point([selLng, selLat]), turf.point(b.geometry.coordinates));
            return distA - distB;
        });
    }

    // Render school list
    list.innerHTML = schoolsInIsochrone.map(feature => {
        const props = feature.properties;
        const isSelected = props.name === currentSelectedKindergartenName;
        
        // Calculate distance from selected school
        let distance = '';
        if (currentSelectedKindergarten) {
            const dist = turf.distance(
                turf.point([currentSelectedKindergarten.lng, currentSelectedKindergarten.lat]), 
                turf.point(feature.geometry.coordinates),
                { units: 'meters' }
            );
            distance = dist < 1000 ? `${Math.round(dist)} áƒ›` : `${(dist/1000).toFixed(1)} áƒ™áƒ›`;
        }

        let html = `<div class="kindergarten-item${isSelected ? ' selected' : ''}" 
                    data-lng="${feature.geometry.coordinates[0]}" 
                    data-lat="${feature.geometry.coordinates[1]}" 
                    data-name="${props.name || ''}"
                    style="border-left: 3px solid #1d91c0;">`;

        html += `<h4>${props.name || 'áƒ£áƒ¡áƒáƒ®áƒ”áƒšáƒ áƒ¡áƒ™áƒáƒšáƒ'}</h4>`;
        
        if (distance) {
            html += `<p>${distance} áƒ›áƒáƒ¨áƒáƒ áƒ”áƒ‘áƒ˜áƒ—</p>`;
        }
        
        if (props.students > 0) {
            html += `<p>áƒ›áƒáƒ¡áƒ¬áƒáƒ•áƒšáƒ”áƒ”áƒ‘áƒ˜: <strong>${props.students}</strong></p>`;
        }
        
        if (props.condition) {
            let conditionColor, conditionLabel;

            switch (props.condition.toLowerCase()) {
                case 'áƒ©áƒáƒ¡áƒáƒœáƒáƒªáƒ•áƒšáƒ”áƒ‘áƒ”áƒšáƒ˜':
                    conditionColor = '#ef4444'; // red
                    conditionLabel = 'áƒ©áƒáƒ¡áƒáƒœáƒáƒªáƒ•áƒšáƒ”áƒ‘áƒ”áƒšáƒ˜áƒ';
                    break;
                case 'áƒªáƒ£áƒ“áƒ˜':
                    conditionColor = '#f97316'; // orange
                    conditionLabel = 'áƒ›áƒáƒ«áƒ•áƒ”áƒšáƒ”áƒ‘áƒ£áƒšáƒ˜ áƒ˜áƒœáƒ¤áƒ áƒáƒ¡áƒ¢áƒ áƒ£áƒ¥áƒ¢áƒ£áƒ áƒ';
                    break;
                case 'áƒ“áƒáƒ›áƒáƒ™áƒ›áƒáƒ§áƒáƒ¤áƒ˜áƒšáƒ”áƒ‘áƒ”áƒšáƒ˜':
                    conditionColor = '#eab308'; // yellow
                    conditionLabel = 'áƒ“áƒáƒ›áƒáƒ™áƒ›áƒáƒ§áƒáƒ¤áƒ˜áƒšáƒ”áƒ‘áƒ”áƒšáƒ˜';
                    break;
                case 'áƒ™áƒáƒ áƒ’áƒ˜':
                    conditionColor = '#22c55e'; // green
                    conditionLabel = 'áƒ™áƒ”áƒ—áƒ˜áƒšáƒ›áƒáƒ¬áƒ§áƒáƒ‘áƒ˜áƒšáƒ˜';
                    break;
                default:
                    conditionColor = '#9ca3af'; // gray
                    conditionLabel = props.condition;
            }

            html += `<p>áƒ›áƒ“áƒ’áƒáƒ›áƒáƒ áƒ”áƒáƒ‘áƒ: <strong style="color: ${conditionColor}">${conditionLabel}</strong></p>`;
        }

        if (props.occupancy > 0) {
            const occupancyColor = props.occupancy > 100 ? '#ef4444' : props.occupancy > 80 ? '#f59e0b' : '#22c55e';
            html += `<p>áƒ“áƒáƒ¢áƒ•áƒ˜áƒ áƒ—áƒ£áƒšáƒáƒ‘áƒ: <strong style="color: ${occupancyColor}">${props.occupancy}%</strong></p>`;
        }

        /*
        // Show costs if available
        const totalCost = (props.urgent_cost || 0) + (props.non_urg_cost || 0) + (props.long_cost || 0);
        if (totalCost > 0) {
            html += `<div style="margin-top: 8px; padding: 8px; background: #f0f9ff; border-radius: 4px; font-size: 11px;">`;
            html += `<div style="font-weight: 600; margin-bottom: 4px;">ğŸ’° áƒ¡áƒáƒ­áƒ˜áƒ áƒ áƒ˜áƒœáƒ•áƒ”áƒ¡áƒ¢áƒ˜áƒªáƒ˜áƒ:</div>`;
            if (props.urgent_cost > 0) html += `<div>â€¢ áƒ¡áƒáƒ¡áƒ¬áƒ áƒáƒ¤áƒ: ${(props.urgent_cost/1000).toFixed(0)}áƒáƒ—. â‚¾</div>`;
            if (props.non_urg_cost > 0) html += `<div>â€¢ áƒáƒ áƒáƒ¡áƒáƒ¡áƒ¬áƒ áƒáƒ¤áƒ: ${(props.non_urg_cost/1000).toFixed(0)}áƒáƒ—. â‚¾</div>`;
            if (props.long_cost > 0) html += `<div>â€¢ áƒ’áƒ áƒ«áƒ”áƒšáƒ•áƒáƒ“áƒ˜áƒáƒœáƒ˜: ${(props.long_cost/1000).toFixed(0)}áƒáƒ—. â‚¾</div>`;
            html += `</div>`;
        }*/

        html += '</div>';
        return html;
    }).join('');

    let currentHoveredFeatureName = null;

    // Add hover & click behavior for schools
    schoolsInIsochrone.forEach((feature, index) => {
        const item = list.children[index];
        if (!item) return;

        const featureLngLat = feature.geometry.coordinates;
        const isSelected = feature.properties.name === currentSelectedKindergartenName;

        item.addEventListener('mouseenter', () => {
            if (isSelected) return;
            if (!map.getLayer('isochrone-schools-layer')) return;

            if (currentHoveredFeatureName && currentHoveredFeatureName !== feature.properties.name) {
                if (map.getLayer('temp-route-line-colored')) map.removeLayer('temp-route-line-colored');
                if (map.getLayer('temp-route-line-colored-outline-glow-outer')) map.removeLayer('temp-route-line-colored-outline-glow-outer');
                if (map.getLayer('temp-route-line-colored-outline-glow-middle')) map.removeLayer('temp-route-line-colored-outline-glow-middle');
                if (map.getSource('temp-route-line-segments')) map.removeSource('temp-route-line-segments');
                const existingPopup = document.getElementById('routePopup');
                if (existingPopup) existingPopup.remove();
            }

            currentHoveredFeatureName = feature.properties.name;

            map.setPaintProperty('isochrone-schools-layer', 'circle-radius', [
                'case', ['==', ['get', 'name'], feature.properties.name], 6, 4
            ]);
            map.setPaintProperty('isochrone-schools-layer', 'circle-stroke-width', [
                'case', ['==', ['get', 'name'], feature.properties.name]
            ]);

            let from;
            if (userLocation) {
                from = userLocation;
            } else if (currentSelectedKindergarten) {
                from = [currentSelectedKindergarten.lng, currentSelectedKindergarten.lat];
            } else {
                return;
            }

            showRoute(from, featureLngLat, resultsMode, false);
        });

        item.addEventListener('click', () => {
            const lng = parseFloat(item.dataset.lng);
            const lat = parseFloat(item.dataset.lat);
            const name = item.dataset.name;

            currentHoveredFeatureName = null;
            currentSelectedKindergarten = { lng, lat };
            currentSelectedKindergartenName = name;

            displaySchoolList(schoolsInIsochrone);
            zoomToSchool({ lng, lat });

            if (userLocation) {
                showRoute(userLocation, [lng, lat], resultsMode, true);
            } else {
                showRouteToSelected([lng, lat], resultsMode, true);
            }

            if (typeof loadStreetViewForKindergarten === 'function') {
                loadStreetViewForKindergarten({ lng, lat });
            }
        });
    });
}

function zoomToKindergarten(lngLat) {
    if (marker) marker.remove();

    currentSelectedKindergarten = { lng: lngLat.lng, lat: lngLat.lat };
    currentFacilityType = 'kindergarten';

    if (kindergartenData && kindergartenData.features) {
        const selected = kindergartenData.features.find(f =>
            f.geometry.coordinates[0] === lngLat.lng && f.geometry.coordinates[1] === lngLat.lat
        );
        currentSelectedKindergartenName = selected ? selected.properties.name : null;
    }
    
    const pulseElement = document.createElement('div');
    pulseElement.className = 'pulsating-dot-kindergarten';
    
    marker = new mapboxgl.Marker({ element: pulseElement, anchor: 'center' })
        .setLngLat([lngLat.lng, lngLat.lat])
        .addTo(map);

    map.flyTo({ center: [lngLat.lng, lngLat.lat], zoom: 15 });
    
    if (currentTab === 'results') {
        generateKindergartenIsochrone(lngLat);
    }

    if (typeof loadStreetViewForKindergarten === 'function') {
        loadStreetViewForKindergarten(lngLat);
    }

    if (typeof loadUrbanEnvironmentAnalysis === 'function') {
        loadUrbanEnvironmentAnalysis(lngLat);
    }
}

function zoomToSchool(lngLat) {
    if (marker) marker.remove();
    
    currentSelectedKindergarten = { lng: lngLat.lng, lat: lngLat.lat };
    currentFacilityType = 'school';

    if (publicSchoolData && publicSchoolData.features) {
        const selected = publicSchoolData.features.find(f =>
            f.geometry.coordinates[0] === lngLat.lng && f.geometry.coordinates[1] === lngLat.lat
        );
        currentSelectedKindergartenName = selected ? selected.properties.áƒ¡áƒ™áƒáƒšáƒ : null;
    }
    
    const pulseElement = document.createElement('div');
    pulseElement.className = 'pulsating-dot-school';
    
    marker = new mapboxgl.Marker({ element: pulseElement, anchor: 'center' })
        .setLngLat([lngLat.lng, lngLat.lat])
        .addTo(map);

    map.flyTo({ 
        center: [lngLat.lng, lngLat.lat], 
        zoom: 16,
        pitch: 60,
        bearing: 0,
        duration: 1500
    });
    
    if (currentTab === 'results') {
        generateSchoolIsochrone(lngLat);
    }

    if (typeof loadStreetViewForKindergarten === 'function') {
        loadStreetViewForKindergarten(lngLat);
    }

    if (typeof loadUrbanEnvironmentAnalysis === 'function') {
        loadUrbanEnvironmentAnalysis(lngLat);
    }
}

function filterPointsByIsochrone(isochronePolygon) {
    if (!kindergartenData || !kindergartenData.features) return [];
    
    const pointsInIsochrone = [];
    kindergartenData.features.forEach(feature => {
        const point = turf.point(feature.geometry.coordinates);
        try {
            if (turf.booleanPointInPolygon(point, isochronePolygon)) {
                pointsInIsochrone.push({
                    type: 'Feature',
                    geometry: feature.geometry,
                    properties: {
                        name: feature.properties.name || '',
                        location: feature.properties.name_location || '',
                        phone: feature.properties.phone || '',
                        email: feature.properties.email || '',
                        facebook: feature.properties.facebook || '',
                        image: feature.properties.image || ''
                    }
                });
            }
        } catch (err) {
            console.error('Error checking kindergarten:', err);
        }
    });
    
    return pointsInIsochrone;
}

function filterSchoolsByIsochrone(isochronePolygon) {
    if (!publicSchoolData || !publicSchoolData.features) return [];
    
    const schoolsInIsochrone = [];
    publicSchoolData.features.forEach(feature => {
        const point = turf.point(feature.geometry.coordinates);
        try {
            if (turf.booleanPointInPolygon(point, isochronePolygon)) {
                schoolsInIsochrone.push({
                    type: 'Feature',
                    geometry: feature.geometry,
                    properties: {
                        name: feature.properties.áƒ¡áƒ™áƒáƒšáƒ || '',
                        students: feature.properties.students || 0,
                        occupancy: feature.properties.occupancy || 0,
                        condition: feature.properties["áƒ¨áƒ”áƒœáƒáƒ‘áƒ˜áƒ¡ áƒ›áƒ“áƒ’áƒáƒ›áƒáƒ áƒ”áƒáƒ‘áƒ"] || 0,
                        urgent_cost: feature.properties.urgent_cost || 0,
                        non_urg_cost: feature.properties.non_urg_cost || 0,
                        long_cost: feature.properties.long_cost || 0,
                        'Ramp': feature.properties['Ramp'] || 'NA',
                        'Adapted elevator': feature.properties['Adapted elevator'] || 'NA',
                        'Adapted WC': feature.properties['Adapted WC'] || 'NA'
                    }
                });
            }
        } catch (err) {
            console.error('Error checking school:', err);
        }
    });
    
    return schoolsInIsochrone;
}

function updatePointsLayer(isochronePolygon) {
    if (currentFacilityType === 'kindergarten') {
        const pointsInIsochrone = filterPointsByIsochrone(isochronePolygon);
        const geoJSON = { type: 'FeatureCollection', features: pointsInIsochrone };
        
        if (map.getSource('isochrone-points')) {
            map.getSource('isochrone-points').setData(geoJSON);
        } else {
            map.addSource('isochrone-points', { type: 'geojson', data: geoJSON });
            map.addLayer({
                id: 'isochrone-points-layer',
                type: 'circle',
                source: 'isochrone-points',
                paint: {
                    'circle-radius': 5,
                    'circle-color': '#ae017e',
                    'circle-opacity': 0.75,
                    'circle-stroke-width': 0.75,
                    'circle-stroke-color': '#ffffff',
                    'circle-radius-transition': { duration: 2000, delay: 3000 },
                    'circle-color-transition': { duration: 2000, delay: 3000 }
                }
            });
        }
        
        displayKindergartenList(pointsInIsochrone);
        document.getElementById('kindergartenResults').style.display = 'block';

        // Hide school summary when kindergarten is selected
        document.getElementById('schoolSummaryResults').style.display = 'none';

    } else if (currentFacilityType === 'school') {
        // Hide kindergarten points when school is selected
        if (map.getSource('isochrone-points')) {
            map.getSource('isochrone-points').setData({ type: 'FeatureCollection', features: [] });
        }
        document.getElementById('kindergartenResults').style.display = 'none';
    }

    // Always update accidents layer regardless of facility type
    if (typeof updateAccidentsLayer === 'function') {
        updateAccidentsLayer(isochronePolygon);
    } 
}

function updateSchoolsLayer(isochronePolygon) {
    if (currentFacilityType === 'school') {
        const schoolsInIsochrone = filterSchoolsByIsochrone(isochronePolygon);
        const geoJSON = { type: 'FeatureCollection', features: schoolsInIsochrone };
        
        if (map.getSource('isochrone-schools')) {
            map.getSource('isochrone-schools').setData(geoJSON);
        } else {
            map.addSource('isochrone-schools', { type: 'geojson', data: geoJSON });
            map.addLayer({
                id: 'isochrone-schools-layer',
                type: 'circle',
                source: 'isochrone-schools',
                paint: {
                    'circle-radius': 5,
                    'circle-color': '#b1e729',
                    'circle-opacity': 0.75,
                    'circle-stroke-width': 0.75,
                    'circle-stroke-color': '#ffffff',
                    'circle-radius-transition': { duration: 2000, delay: 3000 },
                    'circle-color-transition': { duration: 2000, delay: 3000 }
                }
            });
        }
        
        console.log('Schools in isochrone:', schoolsInIsochrone.length);
        displaySchoolList(schoolsInIsochrone);
        
        if (typeof integrateSchoolSummary === 'function') {
            integrateSchoolSummary(schoolsInIsochrone);
        }
        document.getElementById('kindergartenResults').style.display = 'block';

        // Show school summary when school is selected
        document.getElementById('schoolSummaryResults').style.display = 'block';

        } else if (currentFacilityType === 'kindergarten') {

        // Hide schools when kindergarten is selected
        if (map.getSource('isochrone-schools')) {
            map.getSource('isochrone-schools').setData({ type: 'FeatureCollection', features: [] });
        }
        // Hide school summary when kindergarten is selected
        document.getElementById('schoolSummaryResults').style.display = 'none';
    }
}

function generateKindergartenIsochrone(lngLat) {

    // Remove any existing routes when generating new isochrone
    ['route-line', 'temp-route-line'].forEach(routeId => {
        const coloredLayerId = `${routeId}-colored`;
        const outlineLayerId = `${routeId}-colored-outline`;
        const segmentSourceId = `${routeId}-segments`;
        
        if (map.getLayer(`${outlineLayerId}-glow-outer`)) map.removeLayer(`${outlineLayerId}-glow-outer`);
        if (map.getLayer(`${outlineLayerId}-glow-middle`)) map.removeLayer(`${outlineLayerId}-glow-middle`);
        if (map.getLayer(coloredLayerId)) map.removeLayer(coloredLayerId);
        if (map.getLayer(outlineLayerId)) map.removeLayer(outlineLayerId);
        if (map.getSource(segmentSourceId)) map.removeSource(segmentSourceId);
    });
    
    // Remove route popup if exists
    const routePopup = document.getElementById('routePopup');
    if (routePopup) {
        routePopup.remove();
    }

    const time = 15;
    const url = `https://api.mapbox.com/isochrone/v1/mapbox/walking/${lngLat.lng},${lngLat.lat}?contours_minutes=${time}&polygons=true&access_token=${mapboxgl.accessToken}`;

    fetch(url)
        .then(r => r.json())
        .then(data => {
            if (!data.features || data.features.length === 0) return;

            if (map.getSource('iso')) {
                map.getSource('iso').setData(data);
            } else {
                map.addSource('iso', { type: 'geojson', data });
                map.addLayer({
                    id: 'isoLayer',
                    type: 'fill',
                    source: 'iso',
                    paint: {
                        'fill-color': '#5a3fc0',
                        'fill-opacity': 0.3
                    }
                });
            }

            const isochroneFeature = data.features[0];
            currentIsochronePolygon = isochroneFeature;
            
            updatePointsLayer(isochroneFeature);
            updateSchoolsLayer(isochroneFeature);

            const bbox = turf.bbox(isochroneFeature);
            map.fitBounds(bbox, { padding: 0, maxZoom: 19, minZoom: 12 });

            if (marker) {
                marker.remove();
                const pulseElement = document.createElement('div');
                pulseElement.className = 'pulsating-dot-kindergarten';
                marker = new mapboxgl.Marker({ element: pulseElement, anchor: 'center' })
                    .setLngLat([lngLat.lng, lngLat.lat])
                    .addTo(map);
            }

            if (typeof aggregateResultsInIsochrone === 'function') {
                const aggregated = aggregateResultsInIsochrone(isochroneFeature);
                displayAggregatedResults(aggregated);
                document.getElementById('aggregateResults').style.display = 'block';
            }
        })
        .catch(err => console.error('Isochrone error:', err));
}

function generateSchoolIsochrone(lngLat) {

    // Remove any existing routes when generating new isochrone
    ['route-line', 'temp-route-line'].forEach(routeId => {
        const coloredLayerId = `${routeId}-colored`;
        const outlineLayerId = `${routeId}-colored-outline`;
        const segmentSourceId = `${routeId}-segments`;
        
        if (map.getLayer(`${outlineLayerId}-glow-outer`)) map.removeLayer(`${outlineLayerId}-glow-outer`);
        if (map.getLayer(`${outlineLayerId}-glow-middle`)) map.removeLayer(`${outlineLayerId}-glow-middle`);
        if (map.getLayer(coloredLayerId)) map.removeLayer(coloredLayerId);
        if (map.getLayer(outlineLayerId)) map.removeLayer(outlineLayerId);
        if (map.getSource(segmentSourceId)) map.removeSource(segmentSourceId);
    });
    
    // Remove route popup if exists
    const routePopup = document.getElementById('routePopup');
    if (routePopup) {
        routePopup.remove();
    }

    const time = 15;
    const url = `https://api.mapbox.com/isochrone/v1/mapbox/walking/${lngLat.lng},${lngLat.lat}?contours_minutes=${time}&polygons=true&access_token=${mapboxgl.accessToken}`;

    fetch(url)
        .then(r => r.json())
        .then(data => {
            if (!data.features || data.features.length === 0) return;

            if (map.getSource('iso')) {
                map.getSource('iso').setData(data);
            } else {
                map.addSource('iso', { type: 'geojson', data });
                map.addLayer({
                    id: 'isoLayer',
                    type: 'fill',
                    source: 'iso',
                    paint: {
                        'fill-color': '#1d91c0',
                        'fill-opacity': 0.3
                    }
                });
            }

            const isochroneFeature = data.features[0];
            currentIsochronePolygon = isochroneFeature;
            
            updatePointsLayer(isochroneFeature);
            updateSchoolsLayer(isochroneFeature);

            const bbox = turf.bbox(isochroneFeature);
            map.fitBounds(bbox, { padding: 0, maxZoom: 19, minZoom: 12 });

            if (marker) {
                marker.remove();
                const pulseElement = document.createElement('div');
                pulseElement.className = 'pulsating-dot-school';
                marker = new mapboxgl.Marker({ element: pulseElement, anchor: 'center' })
                    .setLngLat([lngLat.lng, lngLat.lat])
                    .addTo(map);
            }

            if (typeof aggregateResultsInIsochrone === 'function') {
                const aggregated = aggregateResultsInIsochrone(isochroneFeature);
                if (typeof displayAggregatedResults === 'function') {
                    displayAggregatedResults(aggregated);
                    document.getElementById('aggregateResults').style.display = 'block';
                }
            }
        })
        .catch(err => console.error('Isochrone error:', err));
}

function switchTab(tab) {
    // Prevent switching to results if user hasn't submitted a survey
    if (tab === 'results' && !userHasSubmittedSurvey) {
        alert('áƒ’áƒ—áƒ®áƒáƒ•áƒ—, áƒáƒ˜áƒ áƒ•áƒ”áƒš áƒ áƒ˜áƒ’áƒ¨áƒ˜ áƒ¨áƒ”áƒáƒ•áƒ¡áƒáƒ— áƒ™áƒ˜áƒ—áƒ®áƒ•áƒáƒ áƒ˜');
        return;
    }
    currentTab = tab;
    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
    
    const searchContainer = document.querySelector('.search-container');
    
    if (tab === 'survey') {
        document.querySelector('.tab-btn:nth-child(1)').classList.add('active');
        document.getElementById('surveyTab').classList.add('active');
        if (map.getSource('iso')) {
            map.getSource('iso').setData({ type: 'FeatureCollection', features: [] });
        }
        if (map.getSource('isochrone-points')) {
            map.getSource('isochrone-points').setData({ type: 'FeatureCollection', features: [] });
        }
        if (map.getSource('isochrone-accidents')) {
            map.getSource('isochrone-accidents').setData({ type: 'FeatureCollection', features: [] });
        }
        if (map.getSource('isochrone-schools')) {
            map.getSource('isochrone-schools').setData({ type: 'FeatureCollection', features: [] });
        }
        document.getElementById('accidentResults').style.display = 'none';
        document.getElementById('aggregateResults').style.display = 'none';
        document.getElementById('kindergartenResults').style.display = 'none';

        // Remove any existing routes and their segment layers
        ['route-line', 'temp-route-line'].forEach(routeId => {
            const coloredLayerId = `${routeId}-colored`;
            const outlineLayerId = `${routeId}-colored-outline`;
            const segmentSourceId = `${routeId}-segments`;
            
            if (map.getLayer(`${outlineLayerId}-glow-outer`)) map.removeLayer(`${outlineLayerId}-glow-outer`);
            if (map.getLayer(`${outlineLayerId}-glow-middle`)) map.removeLayer(`${outlineLayerId}-glow-middle`);
            if (map.getLayer(coloredLayerId)) map.removeLayer(coloredLayerId);
            if (map.getLayer(outlineLayerId)) map.removeLayer(outlineLayerId);
            if (map.getSource(segmentSourceId)) map.removeSource(segmentSourceId);
            
            if (map.getLayer(routeId)) map.removeLayer(routeId);
            const sourceId = routeId === 'route-line' ? 'route-source' : 'temp-route';
            if (map.getSource(sourceId)) map.removeSource(sourceId);
        });

        // Remove popup if exists
        const routePopup = document.getElementById('routePopup');
        if (routePopup) {
            routePopup.remove();
        }

        // Remove the pulsating marker if it exists
        if (marker) {
            marker.remove();
            marker = null;
        }
        
        // Reset the selected kindergarten/school
        currentSelectedKindergarten = null;
        currentSelectedKindergartenName = null;
        currentFacilityType = null;

        // Reset map to initial view
        map.flyTo({
            center: [41.6735867098894, 42.142609674570565],
            zoom: 14,
            pitch: 0,
            bearing: 0,
            duration: 1500
        });
        
    } else if (tab === 'results') {
        document.querySelector('.tab-btn:nth-child(2)').classList.add('active');
        document.getElementById('resultsTab').classList.add('active');
        searchContainer.classList.add('visible');

        // Generate isochrone for the already selected facility
        if (currentSelectedKindergarten) {
            if (currentFacilityType === 'kindergarten') {
                generateKindergartenIsochrone(currentSelectedKindergarten);
            } else if (currentFacilityType === 'school') {
                generateSchoolIsochrone(currentSelectedKindergarten);
            }
        }
    }
}

function setResultsMode(mode) {
    resultsMode = mode;
    document.querySelectorAll('#resultsTab .toggle').forEach(t => t.classList.remove('active'));
    document.querySelector(`#resultsTab .toggle[data-mode="${mode}"]`).classList.add('active');
    
    if (currentSelectedKindergarten && currentTab === 'results' && currentIsochronePolygon) {
        generateKindergartenIsochroneWithMode(currentSelectedKindergarten, mode);
    }
}

function generateKindergartenIsochroneWithMode(lngLat, mode) {

    // Remove any existing routes when generating new isochrone
    ['route-line', 'temp-route-line'].forEach(routeId => {
        const coloredLayerId = `${routeId}-colored`;
        const outlineLayerId = `${routeId}-colored-outline`;
        const segmentSourceId = `${routeId}-segments`;
        
        if (map.getLayer(`${outlineLayerId}-glow-outer`)) map.removeLayer(`${outlineLayerId}-glow-outer`);
        if (map.getLayer(`${outlineLayerId}-glow-middle`)) map.removeLayer(`${outlineLayerId}-glow-middle`);
        if (map.getLayer(coloredLayerId)) map.removeLayer(coloredLayerId);
        if (map.getLayer(outlineLayerId)) map.removeLayer(outlineLayerId);
        if (map.getSource(segmentSourceId)) map.removeSource(segmentSourceId);
    });
    
    // Remove route popup if exists
    const routePopup = document.getElementById('routePopup');
    if (routePopup) {
        routePopup.remove();
    }

    const time = document.getElementById('timeResults').value;
    console.log('Generating isochrone with time:', time, 'mode:', mode);
    const url = `https://api.mapbox.com/isochrone/v1/mapbox/${mode}/${lngLat.lng},${lngLat.lat}?contours_minutes=${time}&polygons=true&access_token=${mapboxgl.accessToken}`;

    fetch(url)
        .then(r => r.json())
        .then(data => {
            console.log('Isochrone response:', data);
            if (!data.features || data.features.length === 0) {
                console.error('No features in isochrone response');
                return;
            }

            if (map.getSource('iso')) {
                map.getSource('iso').setData(data);
            }

            const isochroneFeature = data.features[0];
            currentIsochronePolygon = isochroneFeature;
            
            updatePointsLayer(isochroneFeature);
            updateSchoolsLayer(isochroneFeature);

            const bbox = turf.bbox(isochroneFeature);
            map.fitBounds(bbox, { padding: 0, maxZoom: 20, minZoom: 12 });

            if (typeof aggregateResultsInIsochrone === 'function') {
                const aggregated = aggregateResultsInIsochrone(isochroneFeature);
                displayAggregatedResults(aggregated);
                document.getElementById('aggregateResults').style.display = 'block';
            }
        })
        .catch(err => console.error('Isochrone error:', err));
}
        
        function aggregateResultsInIsochrone(isochronePolygon) {
            const aggregated = { total: 0, age: {}, gender: {}, ageGender: {}, safety: {}, reason: {}, priority: {}, grids: [] };
            surveyDataGeoJSON.features.forEach(feature => {
                const point = turf.point(feature.geometry.coordinates);
                try {
                    if (turf.booleanPointInPolygon(point, isochronePolygon)) {
                        const props = feature.properties;
                        aggregated.grids.push({ name: props.gridName, count: props.responses.length });
                        props.responses.forEach(response => {
                            aggregated.total++;
                            if (response.age) aggregated.age[response.age] = (aggregated.age[response.age] || 0) + 1;
                            if (response.gender) aggregated.gender[response.gender] = (aggregated.gender[response.gender] || 0) + 1;
                            
                            // Cross-tabulate age and gender
                            if (response.age && response.gender) {
                                if (!aggregated.ageGender[response.age]) {
                                    aggregated.ageGender[response.age] = { male: 0, female: 0 };
                                }
                                if (response.gender === 'male' || response.gender === 'female') {
                                    aggregated.ageGender[response.age][response.gender]++;
                                }
                            }
                            
                            if (response.safety) aggregated.safety[response.safety] = (aggregated.safety[response.safety] || 0) + 1;
                            
                            // Split reason by semicolon and count each separately
                            if (response.reason) {
                                const reasons = response.reason.split(';').map(r => r.trim()).filter(r => r);
                                reasons.forEach(r => {
                                    aggregated.reason[r] = (aggregated.reason[r] || 0) + 1;
                                });
                            }
                            
                            // Split priority by semicolon and count each separately
                            if (response.priority) {
                                const priorities = response.priority.split(';').map(p => p.trim()).filter(p => p);
                                priorities.forEach(p => {
                                    aggregated.priority[p] = (aggregated.priority[p] || 0) + 1;
                                });
                            }
                        });
                    }
                } catch (err) {
                    console.error('Error checking feature:', err);
                }
            });
            return aggregated;
        }

        function displayAggregatedResults(data) {
            if (data.total === 0) {
                document.getElementById('aggregateContent').innerHTML = '<p style="text-align: center; font-size: 12px; color: #999; padding: 20px;">áƒáƒ› áƒáƒ áƒ”áƒáƒšáƒ¨áƒ˜ áƒ›áƒáƒœáƒáƒªáƒ”áƒ›áƒ”áƒ‘áƒ˜ áƒáƒ  áƒáƒ áƒ˜áƒ¡</p>';
                return;
            }
            
            const safetyLabels = { very_unsafe: 'áƒ«áƒáƒšáƒ˜áƒáƒœ áƒ¡áƒáƒ®áƒ˜áƒ¤áƒáƒ—áƒáƒ', somewhat_unsafe: 'áƒ›áƒ”áƒ¢áƒ¬áƒ˜áƒšáƒáƒ“ áƒ¡áƒáƒ®áƒ˜áƒ¤áƒáƒ—áƒáƒ', neutral: 'áƒ¡áƒáƒ¨áƒ£áƒáƒšáƒ', somewhat_safe: 'áƒ›áƒ”áƒ¢áƒ¬áƒ˜áƒšáƒáƒ“ áƒ£áƒ¡áƒáƒ¤áƒ áƒ—áƒ®áƒáƒ', very_safe: 'áƒ«áƒáƒšáƒ˜áƒáƒœ áƒ£áƒ¡áƒáƒ¤áƒ áƒ—áƒ®áƒ' };
            const priorityLabels = { safe_crossing: 'áƒ£áƒ¡áƒáƒ¤áƒ áƒ—áƒ®áƒ áƒ¡áƒáƒ¤áƒ”áƒ®áƒ›áƒáƒ•áƒšáƒ áƒ’áƒáƒ“áƒáƒ¡áƒáƒ¡áƒ•áƒšáƒ”áƒšáƒ”áƒ‘áƒ˜', enforcement: 'áƒ›áƒ™áƒáƒªáƒ áƒ˜ áƒ™áƒáƒœáƒ¢áƒ áƒáƒšáƒ˜ áƒ¡áƒáƒ’áƒ–áƒáƒ áƒ›áƒáƒ«áƒ áƒáƒáƒ‘áƒ˜áƒ¡ áƒ¬áƒ”áƒ¡áƒ”áƒ‘áƒ˜áƒ¡ áƒ“áƒáƒ áƒ¦áƒ•áƒ”áƒ•áƒáƒ–áƒ”', limit_speed: 'áƒ›áƒáƒ¥áƒ¡. áƒ“áƒáƒ¡áƒáƒ¨áƒ•áƒ”áƒ‘áƒ˜ áƒ¡áƒ˜áƒ©áƒ¥áƒáƒ áƒ˜áƒ¡ áƒ¨áƒ”áƒ–áƒ¦áƒ£áƒ“áƒ•áƒ 30 áƒ™áƒ›/áƒ¡áƒ—-áƒ›áƒ“áƒ”', infrastructure: 'áƒ˜áƒœáƒ áƒáƒ¡áƒ¢áƒ áƒ£áƒ¥áƒ¢áƒ£áƒ áƒ£áƒšáƒ˜ áƒ’áƒáƒ£áƒ›áƒ¯áƒáƒ‘áƒ”áƒ¡áƒ”áƒ‘áƒ (áƒ¨áƒ£áƒ¥áƒœáƒ˜áƒ¨áƒáƒœáƒ˜, áƒ’áƒ–áƒ˜áƒ¡ áƒ˜áƒœáƒ™áƒšáƒ£áƒ–áƒ˜áƒ£áƒ áƒ˜ áƒ“áƒ˜áƒ–áƒáƒ˜áƒœáƒ˜, áƒ“áƒ áƒ.áƒ¨.)', better_sidewalk: 'áƒ™áƒ”áƒ—áƒ˜áƒšáƒ›áƒáƒ¬áƒ§áƒáƒ‘áƒ˜áƒšáƒ˜ áƒ¢áƒ áƒáƒ¢áƒ£áƒáƒ áƒ”áƒ‘áƒ˜', other_priority: 'áƒ¡áƒ®áƒ•áƒ' };
            const reasonLabels = { sidewalk: 'áƒ•áƒ˜áƒ¬áƒ áƒ áƒ¢áƒ áƒáƒ¢áƒ£áƒáƒ áƒ˜', speed: 'áƒ›áƒáƒ¦áƒáƒšáƒ˜ áƒ¡áƒ˜áƒ©áƒ¥áƒáƒ áƒ”', crossing: 'áƒ£áƒ¨áƒ£áƒ¥áƒœáƒ˜áƒ¨áƒœáƒ/áƒ›áƒáƒ£áƒœáƒ˜áƒ¨áƒœáƒáƒ•áƒ˜ áƒ’áƒáƒ“áƒáƒ¡áƒáƒ¡áƒ•áƒšáƒ”áƒšáƒ˜', road: 'áƒ’áƒáƒœáƒ˜áƒ”áƒ áƒ˜ áƒ¡áƒáƒáƒ•áƒ¢áƒáƒ›áƒáƒ‘áƒ˜áƒšáƒ áƒ–áƒáƒšáƒ˜', drivers: 'áƒ›áƒ«áƒ¦áƒáƒšáƒ”áƒ‘áƒ˜áƒ¡ áƒ¡áƒáƒ®áƒ˜áƒ¤áƒáƒ—áƒ áƒ›áƒáƒœáƒ”áƒ•áƒ áƒ˜', streetlighting: 'áƒªáƒ£áƒ“áƒ˜ áƒ’áƒáƒ áƒ”áƒ’áƒáƒœáƒáƒ—áƒ”áƒ‘áƒ',  other_reason: 'áƒ¡áƒ®áƒ•áƒ'};
            const genderLabels = { male: 'áƒ™áƒáƒªáƒ˜', female: 'áƒ¥áƒáƒšáƒ˜' };
            
            Object.values(chartInstances).forEach(chart => { try { chart.destroy(); } catch(e) {} });
            chartInstances = {};
            
            let html = `<div class="aggregate-stat"><strong>áƒ¡áƒ£áƒš áƒáƒáƒ¡áƒ£áƒ®áƒ˜:</strong> ${data.total}</div>`;
            
            // Age-gender pyramid
            if (Object.keys(data.age).length > 0 && Object.keys(data.gender).length > 0) {
                html += `<div class="chart-container"><h4>áƒáƒ¡áƒáƒ™áƒ˜ áƒ“áƒ áƒ¡áƒ¥áƒ”áƒ¡áƒ˜</h4><div class="chart-wrapper small"><canvas id="pyramidChart"></canvas></div></div>`;
            } else {
                if (Object.keys(data.age).length > 0) html += `<div class="chart-container"><h4>áƒáƒ¡áƒáƒ™áƒ˜</h4><div class="chart-wrapper tiny"><canvas id="ageChart"></canvas></div></div>`;
                if (Object.keys(data.gender).length > 0) html += `<div class="chart-container"><h4>áƒ¡áƒ¥áƒ”áƒ¡áƒ˜</h4><div class="chart-wrapper tiny"><canvas id="genderChart"></canvas></div></div>`;
            }
            
            if (Object.keys(data.safety).length > 0) html += `<div class="chart-container"><h4>áƒ£áƒ¡áƒáƒ¤áƒ áƒ—áƒ®áƒáƒ”áƒ‘áƒ˜áƒ¡ áƒáƒ¦áƒ¥áƒ›áƒ</h4><div class="chart-wrapper small"><canvas id="safetyChart"></canvas></div></div>`;
            if (Object.keys(data.reason).length > 0) html += `<div class="chart-container"><h4>áƒ¡áƒáƒ®áƒ˜áƒ¤áƒáƒ—áƒ áƒ¤áƒáƒ¥áƒ¢áƒáƒ áƒ”áƒ‘áƒ˜</h4><div class="chart-wrapper" style="height: auto; min-height: 150px;"><div id="reasonCloud"></div></div></div>`;
            if (Object.keys(data.priority).length > 0) html += `<div class="chart-container"><h4>áƒáƒ áƒ˜áƒáƒ áƒ˜áƒ¢áƒ”áƒ¢áƒ”áƒ‘áƒ˜</h4><div class="chart-wrapper" style="height: auto; min-height: 150px;"><div id="priorityCloud"></div></div></div>`;
            
            document.getElementById('aggregateContent').innerHTML = html;
            setTimeout(() => createCharts(data, safetyLabels, priorityLabels, reasonLabels, genderLabels), 100);
        }

        function createCharts(data, safetyLabels, priorityLabels, reasonLabels, genderLabels) {
    if (typeof Chart === 'undefined') return;

    const chartConfig = {
        responsive: true,
        maintainAspectRatio: true,
        plugins: {
            legend: { display: false },
            tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                padding: 8,
                titleFont: { size: 11 },
                bodyFont: { size: 10 },
                displayColors: false,
                callbacks: {
                    label: ctx => `${ctx.dataset.label}: ${Math.abs(Math.round(ctx.raw))}`  // Changed here
                }
            }
        }
    };

    // -------------------- Age-Gender Pyramid --------------------
    if ((Object.keys(data.age).length > 0 && Object.keys(data.gender).length > 0) ||
        (data.responses && Array.isArray(data.responses))) {

        const ctx = document.getElementById('pyramidChart')?.getContext('2d');
        if (ctx) {
            let ageGroups = [];
            let maleData = [];
            let femaleData = [];

            if (data.responses && Array.isArray(data.responses)) {
                const ageGenderCount = {};
                data.responses.forEach(r => {
                    if (r.age && r.gender) {
                        if (!ageGenderCount[r.age]) ageGenderCount[r.age] = { male: 0, female: 0 };
                        if (r.gender === 'male' || r.gender === 'female') ageGenderCount[r.age][r.gender]++;
                    }
                });

                ageGroups = Object.keys(ageGenderCount).sort((a, b) => {
                    const numA = parseInt(a.split('-')[0]);
                    const numB = parseInt(b.split('-')[0]);
                    return numB - numA;
                });

                maleData = ageGroups.map(age => -(ageGenderCount[age].male || 0));
                femaleData = ageGroups.map(age => ageGenderCount[age].female || 0);

            } else if (data.ageGender && Object.keys(data.ageGender).length > 0) {
                ageGroups = Object.keys(data.ageGender).sort((a, b) => {
                    const numA = parseInt(a.split('-')[0]);
                    const numB = parseInt(b.split('-')[0]);
                    return numB - numA;
                });

                maleData = ageGroups.map(age => -(data.ageGender[age]?.male || 0));
                femaleData = ageGroups.map(age => data.ageGender[age]?.female || 0);
            }

            chartInstances.pyramid = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ageGroups,
                    datasets: [
                        { 
                            label: genderLabels.male || 'Male', 
                            data: maleData, 
                            backgroundColor: '#6c86cf',
                            categoryPercentage: 1.0,
                            barPercentage: 1.0
                        },
                        { 
                            label: genderLabels.female || 'Female', 
                            data: femaleData, 
                            backgroundColor: '#e7298a',
                            categoryPercentage: 1.0,
                            barPercentage: 1.0
                        }
                    ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        x: {
                            stacked: true,
                            grid: { display: false },
                            ticks: { 
                                callback: function(value, index, ticks) {
                                    const dataValues = new Set();
                                    this.chart.data.datasets.forEach(dataset => {
                                        dataset.data.forEach(val => dataValues.add(Math.abs(val)));
                                    });
                                    return dataValues.has(Math.abs(value)) ? Math.abs(Math.round(value)) : '';
                                },
                                font: { size: 10 },
                                color: '#666'
                            }
                        },
                        y: {
                            stacked: true,
                            grid: { display: false },
                            ticks: { 
                                font: { size: 10 }, 
                                color: '#666' 
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 8,
                            titleFont: { size: 11 },
                            bodyFont: { size: 10 },
                            displayColors: false,
                            callbacks: {
                                label: ctx => `${ctx.dataset.label}: ${Math.abs(Math.round(ctx.raw))}`  // Changed here
                            }
                        }
                    }
                }
            });
        }
    }


            // -------------------- Fallback separate charts --------------------
            else {
                if (Object.keys(data.gender).length > 0) {
                    const ctx = document.getElementById('genderChart')?.getContext('2d');
                    if (ctx) {
                        chartInstances.gender = new Chart(ctx, {
                            type: 'doughnut',
                            data: {
                                labels: Object.keys(data.gender).map(k => genderLabels[k] || k),
                                datasets: [{ data: Object.values(data.gender), backgroundColor: ['#6c86cf', '#e7298a', '#e3f0fc'], borderWidth: 0, barPercentage: 1 // remove space between bars 
                                }]
                            },
                            options: { ...chartConfig, cutout: '75%' }
                        });
                    }
                }

                if (Object.keys(data.age).length > 0) {
                    const ctx = document.getElementById('ageChart')?.getContext('2d');
                    if (ctx) {
                        const sorted = Object.entries(data.age).sort((a, b) => {
                            const numA = parseInt(a[0].split('-')[0]);
                            const numB = parseInt(b[0].split('-')[0]);
                            return numA - numB;
                        });
                        chartInstances.age = new Chart(ctx, {
                            type: 'bar',
                            data: {
                                labels: sorted.map(([k]) => k),
                                datasets: [{ data: sorted.map(([,v]) => v), backgroundColor: '#c5d1f0', borderRadius: 2, borderWidth: 0, barPercentage: 1, // remove space between bars
                                categoryPercentage: 1, barThickness: 'flex' // fills the category width completely
                                }]
                            },
                            options: { ...chartConfig, scales: { y: { display: false, beginAtZero: true }, x: { grid: { display: false }, ticks: { font: { size: 10 }, color: '#666' }, 
                            } } }
                        });
                    }
                }
            }

            // -------------------- Safety Gauge Chart --------------------
            if (Object.keys(data.safety).length > 0) {
                const ctx = document.getElementById('safetyChart')?.getContext('2d');
                if (ctx) {
                    const safetyScores = { 'very_unsafe': 1, 'somewhat_unsafe': 2, 'neutral': 3, 'somewhat_safe': 4, 'very_safe': 5 };
                    let totalScore = 0, totalResponses = 0;
                    Object.entries(data.safety).forEach(([key, count]) => { totalScore += safetyScores[key] * count; totalResponses += count; });
                    const avgScore = totalScore / totalResponses;
                    const percentage = ((avgScore - 1) / 4) * 100;
                    let gaugeColor = avgScore <= 2 ? '#dc2626' : avgScore <= 3 ? '#f59e0b' : avgScore <= 4 ? '#84cc16' : '#22c55e';

                    chartInstances.safety = new Chart(ctx, {
                        type: 'doughnut',
                        data: { datasets: [{ data: [percentage, 100 - percentage], backgroundColor: [gaugeColor, '#e5e7eb'], borderWidth: 0, circumference: 180, rotation: 270 }] },
                        options: { responsive: true, maintainAspectRatio: true, cutout: '75%', plugins: { legend: { display: false }, tooltip: { enabled: false } } },
                        plugins: [{
                            id: 'gaugeText',
                            afterDraw: chart => {
                                const ctx = chart.ctx, cx = chart.width / 2, cy = chart.height / 1.5;
                                ctx.save();
                                ctx.font = 'bold 20px JetBrains Mono';
                                ctx.fillStyle = gaugeColor;
                                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                                ctx.fillText(avgScore.toFixed(1), cx, cy - 10);
                                ctx.font = '10px JetBrains Mono'; ctx.fillStyle = '#666';
                                const label = avgScore <= 2 ? 'áƒ¡áƒáƒ®áƒ˜áƒ¤áƒáƒ—áƒ' : avgScore > 4 ? 'áƒ£áƒ¡áƒáƒ¤áƒ áƒ—áƒ®áƒ' : 'áƒ¡áƒáƒ¨áƒ£áƒáƒšáƒ';
                                ctx.fillText(label, cx, cy + 10);
                                ctx.restore();
                            }
                        }]
                    });
                }
            }

            // -------------------- Word Clouds --------------------
            if (Object.keys(data.priority).length > 0) {
                const container = document.getElementById('priorityCloud');
                if (container) createWordCloud(data.priority, priorityLabels, container, ['#6c86cf', '#a8b9e3', '#5a3fc0', '#8b7fc7']);
            }

            if (Object.keys(data.reason).length > 0) {
                const container = document.getElementById('reasonCloud');
                if (container) createWordCloud(data.reason, reasonLabels, container, ['#810f7c', '#e7298a', '#c51b8a', '#f768a1']);
            }
        }

        function createWordCloud(data, labels, container, colors) {
            const sorted = Object.entries(data).sort((a, b) => b[1] - a[1]);
            const maxCount = sorted[0] ? sorted[0][1] : 1;
            
            container.innerHTML = sorted.map(([key, count], index) => {
                const label = labels[key] || key;
                const fontSize = 10 + (count / maxCount) * 8; // Scale between 10-18px
                const color = colors[index % colors.length];
                return `<span style="display:inline-block; margin:4px 8px; font-size:${fontSize}px; color:${color}; font-weight:500;">${label}</span>`;
            }).join('');
        }

        function createPyramidChart(ctx, ageGroups, maleData, femaleData, genderLabels) {
            chartInstances.pyramid = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ageGroups,
                    datasets: [
                        {
                            label: genderLabels.male,
                            data: maleData,
                            backgroundColor: '#6c86cf',
                            borderRadius: 2,
                            borderWidth: 0,
                            barThickness: 'flex',
                            categoryPercentage: 1.0,
                            barPercentage: 0.9
                        },
                        {
                            label: genderLabels.female,
                            data: femaleData,
                            backgroundColor: '#e7298a',
                            borderRadius: 2,
                            borderWidth: 0,
                            barThickness: 'flex',
                            categoryPercentage: 1.0,
                            barPercentage: 0.9
                        }
                    ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: { font: { size: 11 }, padding: 10 }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 8,
                            titleFont: { size: 11 },
                            bodyFont: { size: 10 },
                            callbacks: {
                                label: function(context) {
                                    const value = Math.abs(context.parsed.x);
                                    return `${context.dataset.label}: ${Math.round(value)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            ticks: {
                                callback: function(value, index, ticks) {
                                    const dataValues = new Set();
                                    this.chart.data.datasets.forEach(dataset => {
                                        dataset.data.forEach(val => dataValues.add(Math.abs(val)));
                                    });
                                    return dataValues.has(Math.abs(value)) ? Math.abs(Math.round(value)) : '';
                                },
                                font: { size: 10 },
                                color: '#666'
                            },
                            grid: { display: false }
                        },
                        y: {
                            stacked: true,
                            grid: { display: false },
                            ticks: { font: { size: 10 }, color: '#666' }
                        }
                    }
                }
            });
        }
        
        const modal = document.getElementById('modal');
        document.querySelector('.close').onclick = () => modal.style.display = 'none';
        window.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };
        

// Your existing form submission
document.getElementById('surveyForm').onsubmit = async (e) => {
    e.preventDefault();

    const form = e.target;
    const submitBtn = form.querySelector('button[type="submit"]');
    const originalText = submitBtn.textContent;
    
    const formData = new FormData(form);
    const cellId = currentFeature.properties.cellId;
    const center = getCellCenter(cellId);
    const gridName = currentFeature.properties.gridName;

    // === VALIDATION START ===

    // Helper for word count
    const wordCount = (str) => str.trim().split(/\s+/).filter(Boolean).length;

    // 1. Radio questions: age, gender, safety
    const requiredRadios = ['age', 'gender', 'safety'];
    for (let name of requiredRadios) {
        const checked = form.querySelector(`input[name="${name}"]:checked`);
        if (!checked) {
            alert(`áƒ’áƒ—áƒ®áƒáƒ•áƒ— áƒ£áƒáƒáƒ¡áƒ£áƒ®áƒáƒ— áƒ§áƒ•áƒ”áƒšáƒ áƒ¡áƒáƒ•áƒáƒšáƒ“áƒ”áƒ‘áƒ£áƒšáƒ áƒ™áƒ˜áƒ—áƒ®áƒ•áƒáƒ¡.`);
            return;
        }
    }

    // 2. Checkboxes: at least 3 in each
    const reasonChecked = form.querySelectorAll('input[name="reason"]:checked');
    if (reasonChecked.length < 3) {
        alert('áƒ’áƒ—áƒ®áƒáƒ•áƒ— áƒ›áƒáƒœáƒ˜áƒ¨áƒœáƒáƒ— áƒ›áƒ˜áƒœáƒ˜áƒ›áƒ£áƒ› áƒ¡áƒáƒ›áƒ˜ áƒ›áƒ˜áƒ–áƒ”áƒ–áƒ˜.');
        return;
    }

    const priorityChecked = form.querySelectorAll('input[name="priority"]:checked');
    if (priorityChecked.length < 3) {
        alert('áƒ’áƒ—áƒ®áƒáƒ•áƒ— áƒ›áƒáƒœáƒ˜áƒ¨áƒœáƒáƒ— áƒ›áƒ˜áƒœáƒ˜áƒ›áƒ£áƒ› áƒ¡áƒáƒ›áƒ˜ áƒáƒ áƒ˜áƒáƒ áƒ˜áƒ¢áƒ”áƒ¢áƒ˜.');
        return;
    }

    // 3. "Other" fields: if checked, must contain â‰¤ 2 words
    const reasonOther = document.getElementById('reasonOtherCheckbox');
    const reasonText = document.getElementById('reasonOtherText');
    if (reasonOther.checked) {
        const count = wordCount(reasonText.value);
        if (count === 0) {
            alert('áƒ’áƒ—áƒ®áƒáƒ•áƒ— áƒ¨áƒ”áƒ˜áƒ§áƒ•áƒáƒœáƒáƒ— áƒ¢áƒ”áƒ¥áƒ¡áƒ¢áƒ˜ áƒ•áƒ”áƒšáƒ¨áƒ˜ "áƒ¡áƒ®áƒ•áƒ" (áƒ›áƒ˜áƒ–áƒ”áƒ–áƒ˜).');
            return;
        }
        if (count > 2) {
            alert('áƒ¡áƒ®áƒ•áƒ áƒáƒáƒ¡áƒ£áƒ®áƒ˜ áƒáƒ  áƒ£áƒœáƒ“áƒ áƒáƒ¦áƒ”áƒ›áƒáƒ¢áƒ”áƒ‘áƒáƒ“áƒ”áƒ¡ áƒáƒ  áƒ¡áƒ˜áƒ¢áƒ§áƒ•áƒáƒ¡ (áƒ›áƒ˜áƒ–áƒ”áƒ–áƒ˜).');
            return;
        }
    }

    const priorityOther = document.getElementById('priorityOtherCheckbox');
    const priorityText = document.getElementById('priorityOtherText');
    if (priorityOther.checked) {
        const count = wordCount(priorityText.value);
        if (count === 0) {
            alert('áƒ’áƒ—áƒ®áƒáƒ•áƒ— áƒ¨áƒ”áƒ˜áƒ§áƒ•áƒáƒœáƒáƒ— áƒ¢áƒ”áƒ¥áƒ¡áƒ¢áƒ˜ áƒ•áƒ”áƒšáƒ¨áƒ˜ "áƒ¡áƒ®áƒ•áƒ" (áƒáƒ áƒ˜áƒáƒ áƒ˜áƒ¢áƒ”áƒ¢áƒ˜).');
            return;
        }
        if (count > 2) {
            alert('áƒ¡áƒ®áƒ•áƒ áƒáƒáƒ¡áƒ£áƒ®áƒ˜ áƒáƒ  áƒ£áƒœáƒ“áƒ áƒáƒ¦áƒ”áƒ›áƒáƒ¢áƒ”áƒ‘áƒáƒ“áƒ”áƒ¡ áƒáƒ  áƒ¡áƒ˜áƒ¢áƒ§áƒ•áƒáƒ¡ (áƒáƒ áƒ˜áƒáƒ áƒ˜áƒ¢áƒ”áƒ¢áƒ˜).');
            return;
        }
    }

    // === VALIDATION END ===

    // Change button state before submission
    submitBtn.textContent = 'áƒ˜áƒ’áƒ–áƒáƒ•áƒœáƒ”áƒ‘áƒ...';
    submitBtn.disabled = true;
    submitBtn.style.opacity = '0.6';
    submitBtn.style.cursor = 'not-allowed';

    try {
        // Continue only if everything is valid
        const reasons = Array.from(document.querySelectorAll('input[name="reason"]:checked'))
            .map(cb => (cb.value === 'other_reason' ? (reasonText.value || '') : cb.value))
            .filter(v => v);

        const priorities = Array.from(document.querySelectorAll('input[name="priority"]:checked'))
            .map(cb => (cb.value === 'other_priority' ? (priorityText.value || '') : cb.value))
            .filter(v => v);

        const response = {
            timestamp: new Date().toISOString(),
            gridName,
            cellId,
            lat: center[1],
            lng: center[0],
            age: formData.get('age'),
            gender: formData.get('gender'),
            safety: formData.get('safety'),
            reason: reasons.join('; '),
            priority: priorities.join('; ')
        };

        console.log('Response object:', response);

        let feature = surveyDataGeoJSON.features.find(f => f.properties.gridName === gridName);
        if (!feature) {
            feature = {
                type: 'Feature',
                geometry: { type: 'Point', coordinates: center },
                properties: { gridName, cellId, responses: [] }
            };
            surveyDataGeoJSON.features.push(feature);
        }

        feature.properties.responses.push({
            timestamp: response.timestamp,
            age: response.age,
            gender: response.gender,
            safety: response.safety,
            reason: response.reason,
            priority: response.priority
        });

        if (map.getSource('survey-data')) map.getSource('survey-data').setData(surveyDataGeoJSON);

        try {
            const result = await fetch(APPS_SCRIPT_URL, {
                method: 'POST',
                body: JSON.stringify(response)
            });
            const resultData = await result.json();
            console.log('Google Sheets response:', resultData);
        } catch (err) {
            console.error('Failed to send to Google Sheets:', err);
        }

        alert('áƒ›áƒáƒ“áƒšáƒáƒ‘áƒ! áƒ—áƒ¥áƒ•áƒ”áƒœáƒ˜ áƒáƒáƒ¡áƒ£áƒ®áƒ˜ áƒ¨áƒ”áƒœáƒáƒ®áƒ£áƒšáƒ˜áƒ.');
        modal.style.display = 'none';
        form.reset();
        reasonText.style.display = 'none';
        priorityText.style.display = 'none';

        // Clear highlighted grid
        if (map.getSource('highlighted-grid')) {
            map.getSource('highlighted-grid').setData({ type: 'FeatureCollection', features: [] });
        }

        updateGridLayer();
        
        // Enable results tab after user submits their first response
        if (!userHasSubmittedSurvey) {
            userHasSubmittedSurvey = true;
            enableResultsTab();
            console.log('First survey submitted - results tab should be enabled');
        }
        
    } catch (error) {
        console.error('Survey submission error:', error);
        alert('áƒ¨áƒ”áƒªáƒ“áƒáƒ›áƒ. áƒ’áƒ—áƒ®áƒáƒ•áƒ— áƒ¡áƒªáƒáƒ“áƒáƒ— áƒ—áƒáƒ•áƒ˜áƒ“áƒáƒœ.');
    } finally {
        // Restore button state
        submitBtn.textContent = originalText;
        submitBtn.disabled = false;
        submitBtn.style.opacity = '1';
        submitBtn.style.cursor = 'pointer';
    }
};
        
        // OPTIMIZED updateGridLayer with debouncing
        let gridUpdateTimeout;
        function updateGridLayer() {
            clearTimeout(gridUpdateTimeout);
            gridUpdateTimeout = setTimeout(() => {
                const zoom = map.getZoom();
                
                // Only show grid at zoom 11+
                if (zoom < 11) {
                    if (map.getSource('grid')) {
                        map.getSource('grid').setData({ type: 'FeatureCollection', features: [] });
                    }
                    return;
                }
                
                const bounds = map.getBounds();
                const features = [];
                const existingGrids = {};
                const centerPoint = turf.point(MAP_CENTER);

                surveyDataGeoJSON.features.forEach(f => {
                    existingGrids[f.properties.cellId] = { 
                        gridName: f.properties.gridName, 
                        count: f.properties.responses.length 
                    };
                });

                // Calculate grid size based on meters
                const avgLat = (bounds.getSouth() + bounds.getNorth()) / 2;
                const { latDeg: GRID_SIZE_LAT, lonDeg: GRID_SIZE_LNG } = metersToDegrees(avgLat, GRID_SIZE_METERS);

                const startLng = Math.floor(bounds.getWest() / GRID_SIZE_LNG) * GRID_SIZE_LNG;
                const startLat = Math.floor(bounds.getSouth() / GRID_SIZE_LAT) * GRID_SIZE_LAT;
                
                for (let lng = startLng; lng <= bounds.getEast(); lng += GRID_SIZE_LNG) {
                    for (let lat = startLat; lat <= bounds.getNorth(); lat += GRID_SIZE_LAT) {
                        const cellCenter = [lng + GRID_SIZE_LNG/2, lat + GRID_SIZE_LAT/2];
                        const cellCenterPoint = turf.point(cellCenter);
                        const distanceKm = turf.distance(centerPoint, cellCenterPoint, { units: 'kilometers' });
                        
                        // Only show cells within 20km radius
                        if (distanceKm > MAX_GRID_RADIUS_KM) continue;
                        
                        const cellId = getCellId(lng, lat);
                        const existing = existingGrids[cellId];
                        const count = existing ? existing.count : 0;
                        const gridName = existing ? existing.gridName : generateThreeWordName(cellId);

                        // In results tab with isochrone, only show intersecting grids
                        if (currentTab === 'results' && currentIsochronePolygon) {
                            if (count > 0) {
                                const gridPolygon = turf.polygon([getCellBounds(cellId, lng, lat, GRID_SIZE_LNG, GRID_SIZE_LAT)]);
                                try {
                                    if (turf.booleanIntersects(gridPolygon, currentIsochronePolygon)) {
                                        features.push({
                                            type: 'Feature',
                                            properties: { cellId, gridName, count, hasData: true },
                                            geometry: { type: 'Polygon', coordinates: [getCellBounds(cellId, lng, lat, GRID_SIZE_LNG, GRID_SIZE_LAT)] }
                                        });
                                    }
                                } catch (err) {
                                    console.error('Error checking grid intersection:', err);
                                }
                            }
                        } 
                        // In survey tab, show all grids
                        else if (currentTab === 'survey') {
                            if (count > 0 || zoom > 12) {
                                features.push({
                                    type: 'Feature',
                                    properties: { cellId, gridName, count, hasData: count > 0 },
                                    geometry: { type: 'Polygon', coordinates: [getCellBounds(cellId, lng, lat, GRID_SIZE_LNG, GRID_SIZE_LAT)] }
                                });
                            }
                        }
                    }
                }

                if (map.getSource('grid')) {
                    map.getSource('grid').setData({ type: 'FeatureCollection', features });
                }
            }, 150); // Debounce by 150ms
        }
        map.on('click', (e) => {
            if (currentTab === 'survey') {
                const features = map.queryRenderedFeatures(e.point, { layers: ['grid-layer'] });
                if (features.length > 0) {
                    const props = features[0].properties;
                    const gridName = props.gridName || generateThreeWordName(props.cellId);
                    currentFeature = { properties: { cellId: props.cellId, gridName, count: props.count } };
                    const center = getCellCenter(props.cellId);
                    
                    // Existing survey modal code...
                    const gridBounds = getCellBounds(props.cellId);
                    const highlightedGrid = {
                        type: 'FeatureCollection',
                        features: [{
                            type: 'Feature',
                            properties: { cellId: props.cellId },
                            geometry: { 
                                type: 'Polygon', 
                                coordinates: [gridBounds] 
                            }
                        }]
                    };
                    
                    if (map.getSource('highlighted-grid')) {
                        map.getSource('highlighted-grid').setData(highlightedGrid);
                    }
                    
                    document.getElementById('cellInfo').innerHTML = 
                        `<div class="three-word-name" style="text-align: center">${gridName}</div>`;
                    modal.style.display = 'block';
                }
            } else if (currentTab === 'results') {
                // NEW: Generate isochrone from map click in results tab
                const lngLat = { lng: e.lngLat.lng, lat: e.lngLat.lat };
                
                // Check if click is on an existing facility
                const kindergartenFeatures = map.queryRenderedFeatures(e.point, { 
                    layers: ['kindergartens-layer'] 
                });
                const schoolFeatures = map.queryRenderedFeatures(e.point, { 
                    layers: ['isochrone-schools-layer'] 
                });
                
                // If clicked on a facility, use existing zoom function
                if (kindergartenFeatures.length > 0) {
                    const coords = kindergartenFeatures[0].geometry.coordinates;
                    zoomToKindergarten({ lng: coords[0], lat: coords[1] });
                } else if (schoolFeatures.length > 0) {
                    const coords = schoolFeatures[0].geometry.coordinates;
                    zoomToSchool({ lng: coords[0], lat: coords[1] });
                } else {
                    // Generate isochrone from arbitrary map point
                    generateIsochroneFromClick(lngLat);
                }
            }
        });
        
        //generate isochrone on map click in results tab
        function generateIsochroneFromClick(lngLat) {
            if (marker) marker.remove();
            
            currentSelectedKindergarten = { lng: lngLat.lng, lat: lngLat.lat };
            currentSelectedKindergartenName = null;
            currentFacilityType = null;
            
            // Add a temporary marker
            const pulseElement = document.createElement('div');
            pulseElement.className = 'pulsating-dot-custom';
            pulseElement.style.cssText = `
                width: 20px;
                height: 20px;
                background: #f59e0b;
                border-radius: 50%;
                animation: pulse 2s infinite;
            `;
            
            marker = new mapboxgl.Marker({ element: pulseElement, anchor: 'center' })
                .setLngLat([lngLat.lng, lngLat.lat])
                .addTo(map);

            // Remove existing routes
            ['route-line', 'temp-route-line'].forEach(routeId => {
                const coloredLayerId = `${routeId}-colored`;
                const outlineLayerId = `${routeId}-colored-outline`;
                const segmentSourceId = `${routeId}-segments`;
                
                if (map.getLayer(`${outlineLayerId}-glow-outer`)) map.removeLayer(`${outlineLayerId}-glow-outer`);
                if (map.getLayer(`${outlineLayerId}-glow-middle`)) map.removeLayer(`${outlineLayerId}-glow-middle`);
                if (map.getLayer(coloredLayerId)) map.removeLayer(coloredLayerId);
                if (map.getLayer(outlineLayerId)) map.removeLayer(outlineLayerId);
                if (map.getSource(segmentSourceId)) map.removeSource(segmentSourceId);
            });
            
            const routePopup = document.getElementById('routePopup');
            if (routePopup) routePopup.remove();

            const time = document.getElementById('timeResults').value;
            const url = `https://api.mapbox.com/isochrone/v1/mapbox/${resultsMode}/${lngLat.lng},${lngLat.lat}?contours_minutes=${time}&polygons=true&access_token=${mapboxgl.accessToken}`;

            fetch(url)
                .then(r => r.json())
                .then(data => {
                    if (!data.features || data.features.length === 0) return;

                    if (map.getSource('iso')) {
                        map.getSource('iso').setData(data);
                    }

                    const isochroneFeature = data.features[0];
                    currentIsochronePolygon = isochroneFeature;
                    
                    updatePointsLayer(isochroneFeature);
                    updateSchoolsLayer(isochroneFeature);

                    const bbox = turf.bbox(isochroneFeature);
                    map.fitBounds(bbox, { padding: 50, maxZoom: 16 });

                    if (typeof aggregateResultsInIsochrone === 'function') {
                        const aggregated = aggregateResultsInIsochrone(isochroneFeature);
                        if (typeof displayAggregatedResults === 'function') {
                            displayAggregatedResults(aggregated);
                            document.getElementById('aggregateResults').style.display = 'block';
                        }
                    }
                    
                    if (typeof loadStreetViewForKindergarten === 'function') {
                        loadStreetViewForKindergarten(lngLat);
                    }
                })
                .catch(err => console.error('Isochrone error:', err));
        }

        // 7. Add CSS for custom marker animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes pulse {
                0% {
                    box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.7);
                }
                70% {
                    box-shadow: 0 0 0 10px rgba(245, 158, 11, 0);
                }
                100% {
                    box-shadow: 0 0 0 0 rgba(245, 158, 11, 0);
                }
            }
            .pulsating-dot-custom {
                animation: pulse 2s infinite;
            }
        `;
        document.head.appendChild(style);

        map.on('load', () => {
            map.addSource('grid', { type: 'geojson', data: fixedGrid });
            
            map.addLayer({
                id: 'grid-layer',
                type: 'fill',
                source: 'grid',
                paint: {
                    'fill-color': ['case', ['>', ['get', 'count'], 0], ['interpolate', ['linear'], ['get', 'count'], 1, '#e3f0fc', 5, '#6c86cf', 10, '#4a6bb0'], '#ffffff'],
                    'fill-opacity': 0.05
                },
                minzoom: 11
            });
            
            map.addLayer({
                id: 'grid-outline',
                type: 'line',
                source: 'grid',
                paint: {
                    'line-color': '#6c86cf',
                    'line-opacity': 0.25,
                    'line-width': ['interpolate', ['linear'], ['zoom'], 10, 0.5, 12, 0.75, 14, 1, 16, 3]
                }
            });

            // Add highlighted grid layer (initially empty)
            map.addSource('highlighted-grid', { 
                type: 'geojson', 
                data: { type: 'FeatureCollection', features: [] } 
            });
            
            map.addLayer({
                id: 'highlighted-grid-fill',
                type: 'fill',
                source: 'highlighted-grid',
                paint: {
                    'fill-color': '#810f7c',
                    'fill-opacity': 0.3
                }
            });
            
            map.addLayer({
                id: 'highlighted-grid-outline',
                type: 'line',
                source: 'highlighted-grid',
                paint: {
                    'line-color': '#810f7c',
                    'line-width': 3,
                    'line-opacity': 0.8
                }
            });
            
            map.addSource('survey-data', { type: 'geojson', data: surveyDataGeoJSON });
            map.addSource('kindergartens', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
            
            map.addLayer({
                id: 'kindergartens-layer',
                type: 'circle',
                source: 'kindergartens',
                paint: {
                    'circle-radius': ['interpolate', ['linear'], ['zoom'], 10, 1, 14, 2, 16, 4],
                    'circle-color': '#810f7c',
                    'circle-opacity': 0.75,
                    'circle-stroke-width': 0.75,
                    'circle-stroke-color': '#ffffff'
                },
                layout: { 'visibility': 'none' }
            });
            
            map.addLayer({
                id: 'kindergartens-labels',
                type: 'symbol',
                source: 'kindergartens',
                layout: {
                    'text-field': ['get', 'name'],
                    'text-font': ['Noto Sans Georgian Regular', 'Arial Unicode MS Regular'],
                    'text-size': 11,
                    'text-offset': [0, 1.5],
                    'text-anchor': 'top',
                    'visibility': 'none'
                },
                paint: {
                    'text-color': '#810f7c',
                    'text-halo-color': '#ffffff',
                    'text-halo-width': 2
                },
                minzoom: 13
            });
            
            map.addSource('iso', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
            map.addLayer({ id: 'iso-layer', type: 'fill', source: 'iso', paint: { 'fill-color': '#6c86cf', 'fill-opacity': 0.2 } });
            map.addLayer({ id: 'iso-outline', type: 'line', source: 'iso', paint: { 'line-color': '#6c86cf', 'line-width': 2 } });

            map.addSource('car-accidents', { 
                type: 'geojson', 
                data: { type: 'FeatureCollection', features: [] } 
            });

            loadCarAccidentData();
            loadKindergartenData();
            loadDataFromSheets();
            updateGridLayer();
            // Initialize state tracking
            initializeMapStateTracking(map);
            
            // Initialize share buttons
            initializeShareButtons();
            
            // Apply URL state after everything is loaded
            setTimeout(() => {
                applyUrlState();
            }, 2000);
        });

        map.on('moveend', updateGridLayer);
        map.on('zoomend', updateGridLayer);
        
        document.getElementById('timeResults').addEventListener('change', () => {
            console.log('Time changed to:', document.getElementById('timeResults').value);
            if (currentSelectedKindergarten && currentTab === 'results') {
                generateKindergartenIsochroneWithMode(currentSelectedKindergarten, resultsMode);
            }
        });
    </script>
</body>
</html>